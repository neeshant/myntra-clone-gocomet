{"ast":null,"code":"import React, { Component, useContext, useRef, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nvar initialState = {\n  // components\n  wrapperComponent: null,\n  contentComponent: null,\n  // settings\n  limitToBounds: true,\n  disabled: false,\n  // position\n  isCentered: true,\n  transformEnabled: true,\n  positionX: 0,\n  positionY: 0,\n  maxPositionX: null,\n  minPositionX: null,\n  maxPositionY: null,\n  minPositionY: null,\n  // scale\n  zoomingEnabled: true,\n  scale: 1,\n  maxScale: 8,\n  minScale: 1,\n  previousScale: 1,\n  scaleAnimationPadding: 0.15,\n  // wheel\n  wheelStep: 4,\n  enableWheel: true,\n  enableTouchPadPinch: true,\n  // pinch\n  pinchEnabled: true,\n  pinchSensitivity: 1,\n  startPinchDistance: null,\n  //panning\n  panningEnabled: true,\n  limitToWrapperBounds: false,\n  startPanningCoords: null,\n  lockAxisX: false,\n  lockAxisY: false,\n  // velocity\n  velocityTimeBasedOnMove: true,\n  minVelocity: 1.8,\n  enableVelocity: true,\n  minVelocityScale: 1,\n  // animations\n  velocityAnimationSpeed: 1800,\n  zoomAnimationSpeed: 200,\n  velocitySensitivity: 1,\n  // controls\n  dbClickEnabled: true,\n  dbClickMode: \"zoomIn\",\n  zoomInStep: 40,\n  zoomOutStep: 40,\n  dbClickStep: 40,\n  zoomInAnimationSpeed: 200,\n  zoomOutAnimationSpeed: 200,\n  dbClickAnimationSpeed: 200,\n  resetAnimationSpeed: 200,\n  scalePaddingAnimationSpeed: 200\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/**\n * Rounds number to given decimal\n * eg. roundNumber(2.34343, 1) => 2.3\n */\n\n\nvar roundNumber = function roundNumber(num) {\n  var decimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  return Number(num.toFixed(decimal));\n};\n/**\n * Checks if value is number, if not it returns default value\n * 1# eg. checkIsNumber(2, 30) => 2\n * 2# eg. checkIsNumber(null, 30) => 30\n */\n\n\nvar checkIsNumber = function checkIsNumber(num, defaultValue) {\n  return typeof num === \"number\" ? num : defaultValue;\n};\n/**\n * Keeps value between given bounds, used for limiting view to given boundaries\n * 1# eg. boundLimiter(2, 0, 3, true) => 2\n * 2# eg. boundLimiter(4, 0, 3, true) => 3\n * 3# eg. boundLimiter(-2, 0, 3, true) => 0\n * 4# eg. boundLimiter(10, 0, 3, false) => 10\n */\n\n\nvar boundLimiter = function boundLimiter(value, minBound, maxBound, isActive) {\n  if (!isActive) return roundNumber(value, 2);\n  if (value < minBound) return roundNumber(minBound, 2);\n  if (value > maxBound) return roundNumber(maxBound, 2);\n  return roundNumber(value, 2);\n};\n/**\n * Calculate bounding area of zoomed/panned element\n */\n\n\nvar calculateBoundingArea = function calculateBoundingArea(wrapperWidth, contentWidth, diffWidth, wrapperHeight, contentHeight, diffHeight, limitToWrapperBounds) {\n  var scaleWidthFactor = wrapperWidth > contentWidth ? diffWidth * (limitToWrapperBounds ? 1 : 0.5) : 0;\n  var scaleHeightFactor = wrapperHeight > contentHeight ? diffHeight * (limitToWrapperBounds ? 1 : 0.5) : 0;\n  var minPositionX = wrapperWidth - contentWidth - scaleWidthFactor;\n  var maxPositionX = 0 + scaleWidthFactor;\n  var minPositionY = wrapperHeight - contentHeight - scaleHeightFactor;\n  var maxPositionY = 0 + scaleHeightFactor;\n  return {\n    minPositionX: minPositionX,\n    maxPositionX: maxPositionX,\n    minPositionY: minPositionY,\n    maxPositionY: maxPositionY\n  };\n};\n/**\n * Returns distance between two points x,y\n */\n\n\nvar getDistance = function getDistance(firstPoint, secondPoint) {\n  return Math.sqrt(Math.pow(firstPoint.pageX - secondPoint.pageX, 2) + Math.pow(firstPoint.pageY - secondPoint.pageY, 2));\n};\n/**\n * Delete undefined values from object keys\n * Used for deleting empty props\n */\n\n\nvar deleteUndefinedProps = function deleteUndefinedProps(value) {\n  var newObject = _extends({}, value);\n\n  Object.keys(newObject).forEach(function (key) {\n    return newObject[key] == undefined && delete newObject[key];\n  });\n  return newObject;\n};\n/**\n * Fire callback if it's function\n */\n\n\nvar handleCallback = function handleCallback(callback, props) {\n  if (callback && typeof callback === \"function\") {\n    callback(props);\n  }\n};\n/**\n * Functions should return denominator of the target value, which is the next animation step.\n * animationProgress is a value from 0 to 1, reflecting the percentage of animation status.\n */\n\n\nfunction easeOut(animationProgress) {\n  return -Math.cos(animationProgress * Math.PI) / 2 + 0.5;\n}\n\nfunction easeIn(animationProgress) {\n  return -Math.sin(animationProgress * Math.PI) / 2 + 0.5;\n}\n\nfunction linear(animationProgress) {\n  return animationProgress;\n}\n\nfunction handleDisableAnimation() {\n  this.velocity = null;\n  this.animate = false;\n  this.setState({\n    startAnimation: false\n  });\n}\n\nfunction animateFunction(_ref) {\n  var _this = this;\n\n  var animationVariable = _ref.animationVariable,\n      animationTime = _ref.animationTime,\n      callback = _ref.callback,\n      cancelCallback = _ref.cancelCallback,\n      doneCallback = _ref.doneCallback,\n      _ref$animationName = _ref.animationName,\n      animationName = _ref$animationName === undefined ? \"easeOut\" : _ref$animationName;\n  var lastStep = 1;\n\n  if (this.animate) {\n    cancelAnimationFrame(this.animate);\n    cancelCallback();\n  }\n\n  var startTime = new Date().getTime(); // if animation has only one step\n\n  if (animationTime === 1) {\n    callback(lastStep);\n    doneCallback();\n    this.animate = null;\n    return;\n  }\n\n  this.animate = function () {\n    if (!_this.animate) return;\n    var frameTime = new Date().getTime() - startTime;\n    var animationProgress = frameTime / animationTime;\n    var animationType = {\n      easeOut: easeOut,\n      easeIn: easeIn,\n      linear: linear\n    }[animationName];\n    var step = animationType(animationProgress);\n\n    if (frameTime >= animationTime) {\n      callback(lastStep);\n      doneCallback();\n      _this.animate = null;\n    } else {\n      callback(step);\n      requestAnimationFrame(_this.animate);\n    }\n  };\n\n  requestAnimationFrame(this.animate);\n}\n\nfunction animatePaddingFunction(_ref2) {\n  var _this2 = this;\n\n  var animationTime = _ref2.animationTime,\n      callback = _ref2.callback,\n      cancelCallback = _ref2.cancelCallback,\n      doneCallback = _ref2.doneCallback,\n      _ref2$animationName = _ref2.animationName,\n      animationName = _ref2$animationName === undefined ? \"easeOut\" : _ref2$animationName;\n  var lastStep = 1;\n\n  if (this.zoomPaddingAnimation) {\n    cancelAnimationFrame(this.zoomPaddingAnimation);\n    cancelCallback();\n  }\n\n  var startTime = new Date().getTime(); // if animation has only one step\n\n  if (animationTime === 1) {\n    callback(lastStep);\n    doneCallback();\n    this.zoomPaddingAnimation = null;\n    return;\n  }\n\n  this.zoomPaddingAnimation = function () {\n    if (!_this2.zoomPaddingAnimation) return;\n    var frameTime = new Date().getTime() - startTime;\n    var animationProgress = frameTime / animationTime;\n    var animationType = {\n      easeOut: easeOut,\n      easeIn: easeIn,\n      linear: linear\n    }[animationName];\n    var step = animationType(animationProgress);\n\n    if (frameTime >= animationTime) {\n      callback(lastStep);\n      doneCallback();\n      _this2.zoomPaddingAnimation = null;\n    } else {\n      callback(step);\n      requestAnimationFrame(_this2.zoomPaddingAnimation);\n    }\n  };\n\n  requestAnimationFrame(this.zoomPaddingAnimation);\n}\n\nfunction checkZoomBounds(zoom, minScale, maxScale, scaleAnimationPadding) {\n  var maxScaleWithPadding = maxScale + scaleAnimationPadding;\n  var minScaleWithPadding = minScale - scaleAnimationPadding;\n  if (!isNaN(maxScale) && zoom >= maxScaleWithPadding) return maxScaleWithPadding;\n  if (!isNaN(minScale) && zoom <= minScaleWithPadding) return minScaleWithPadding;\n  return zoom;\n}\n\nfunction checkPositionBounds(positionX, positionY, bounds, limitToBounds) {\n  var minPositionX = bounds.minPositionX,\n      minPositionY = bounds.minPositionY,\n      maxPositionX = bounds.maxPositionX,\n      maxPositionY = bounds.maxPositionY;\n  var x = boundLimiter(positionX, minPositionX, maxPositionX, limitToBounds);\n  var y = boundLimiter(positionY, minPositionY, maxPositionY, limitToBounds);\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction getDelta(event, customDelta) {\n  var deltaY = event ? event.deltaY < 0 ? 1 : -1 : 0;\n  var delta = checkIsNumber(customDelta, deltaY);\n  return delta;\n}\n\nfunction wheelMousePosition(event, contentComponent, scale) {\n  var contentRect = contentComponent.getBoundingClientRect(); // mouse position x, y over wrapper component\n\n  var mouseX = (event.clientX - contentRect.left) / scale;\n  var mouseY = (event.clientY - contentRect.top) / scale;\n  if (isNaN(mouseX) || isNaN(mouseY)) return console.warn(\"No mouse or touch offset found\");\n  return {\n    mouseX: mouseX,\n    mouseY: mouseY\n  };\n}\n\nfunction getComponentsSizes(wrapperComponent, newScale) {\n  var wrapperRect = wrapperComponent.getBoundingClientRect();\n  var wrapperWidth = wrapperRect.width;\n  var wrapperHeight = wrapperRect.height;\n  var newContentWidth = wrapperWidth * newScale;\n  var newContentHeight = wrapperHeight * newScale;\n  var newDiffWidth = wrapperWidth - newContentWidth;\n  var newDiffHeight = wrapperHeight - newContentHeight;\n  return {\n    wrapperWidth: wrapperWidth,\n    wrapperHeight: wrapperHeight,\n    newContentWidth: newContentWidth,\n    newDiffWidth: newDiffWidth,\n    newContentHeight: newContentHeight,\n    newDiffHeight: newDiffHeight\n  };\n}\n\nfunction calculateZoom(zoomStep, delta, customScale, disabledPadding) {\n  var _stateProvider = this.stateProvider,\n      scale = _stateProvider.scale,\n      maxScale = _stateProvider.maxScale,\n      minScale = _stateProvider.minScale,\n      scaleAnimationPadding = _stateProvider.scaleAnimationPadding;\n  var padding = disabledPadding ? 0 : scaleAnimationPadding;\n  if (typeof customScale === \"number\" && customScale === scale) return scale;\n  if (typeof customScale === \"number\") return checkZoomBounds(customScale, minScale, maxScale, padding);\n  var newScale = scale + zoomStep * delta * (scale / 100);\n  var calculatedScale = checkZoomBounds(roundNumber(newScale, 2), minScale, maxScale, padding);\n  if (scale === calculatedScale) return scale;\n  return calculatedScale;\n}\n\nfunction calculateTransformation(mouseX, mouseY, scaleDifference, bounds) {\n  if (typeof mouseX !== \"number\" || typeof mouseY !== \"number\") return console.error(\"Mouse X and Y position were not provided!\");\n  var _stateProvider2 = this.stateProvider,\n      positionX = _stateProvider2.positionX,\n      positionY = _stateProvider2.positionY,\n      limitToBounds = _stateProvider2.limitToBounds,\n      transformEnabled = _stateProvider2.transformEnabled;\n  if (!transformEnabled) return {\n    newPositionX: positionX,\n    newPositionY: positionY\n  };\n  var calculatedPositionX = positionX - mouseX * scaleDifference;\n  var calculatedPositionY = positionY - mouseY * scaleDifference;\n\n  var _checkPositionBounds = checkPositionBounds(calculatedPositionX, calculatedPositionY, bounds, limitToBounds),\n      x = _checkPositionBounds.x,\n      y = _checkPositionBounds.y;\n\n  return {\n    newPositionX: x,\n    newPositionY: y\n  };\n}\n\nfunction handleZoom(event, customMousePosition, customDelta, customStep, animationTime, disabledPadding) {\n  var _this = this;\n\n  var _stateProvider3 = this.stateProvider,\n      isDown = _stateProvider3.isDown,\n      zoomingEnabled = _stateProvider3.zoomingEnabled,\n      disabled = _stateProvider3.disabled,\n      scale = _stateProvider3.scale,\n      limitToWrapperBounds = _stateProvider3.limitToWrapperBounds,\n      wheelStep = _stateProvider3.wheelStep,\n      positionY = _stateProvider3.positionY,\n      positionX = _stateProvider3.positionX;\n  var _state = this.state,\n      wrapperComponent = _state.wrapperComponent,\n      contentComponent = _state.contentComponent;\n  if (isDown || !zoomingEnabled || disabled) return;\n\n  if (disabledPadding && this.zoomPaddingTimer) {\n    clearTimeout(this.zoomPaddingTimer);\n    this.zoomPaddingTimer = null;\n  }\n\n  event.preventDefault();\n  event.stopPropagation(); // Scale transformation\n\n  var delta = getDelta(event, customDelta);\n  var targetScale = calculateZoom.bind(this, customStep || wheelStep, delta, null, disabledPadding)();\n  if (targetScale === scale) return; // Get new element sizes to calculate bounds\n\n  var _getComponentsSizes = getComponentsSizes(wrapperComponent, targetScale),\n      wrapperWidth = _getComponentsSizes.wrapperWidth,\n      wrapperHeight = _getComponentsSizes.wrapperHeight,\n      newContentWidth = _getComponentsSizes.newContentWidth,\n      newDiffWidth = _getComponentsSizes.newDiffWidth,\n      newContentHeight = _getComponentsSizes.newContentHeight,\n      newDiffHeight = _getComponentsSizes.newDiffHeight; // Position transformation\n\n\n  var _ref = customMousePosition || wheelMousePosition(event, contentComponent, scale),\n      mouseX = _ref.mouseX,\n      mouseY = _ref.mouseY;\n\n  var scaleDifference = targetScale - scale;\n  var bounds = calculateBoundingArea(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, limitToWrapperBounds); // Save last zoom bounds, to speed up panning function\n\n  this.bounds = bounds;\n  this.lastDelta = delta; // Calculate transformations\n\n  var _calculateTransformat = calculateTransformation.bind(this, mouseX, mouseY, scaleDifference, bounds)(),\n      newPositionX = _calculateTransformat.newPositionX,\n      newPositionY = _calculateTransformat.newPositionY;\n\n  var speed = checkIsNumber(animationTime, 1);\n\n  if (!animationTime || Math.abs(scaleDifference) < 0.05) {\n    this.stateProvider = _extends({}, this.stateProvider, {\n      positionX: newPositionX,\n      positionY: newPositionY,\n      scale: targetScale,\n      previousScale: scale\n    }); // update component transformation\n\n    this.setContentComponentTransformation();\n  } else {\n    // animate\n    var params = {\n      animationVariable: disabledPadding ? this.zoomPaddingAnimation : this.animate,\n      animationTime: speed,\n      animationName: \"linear\",\n      callback: function callback(step) {\n        var newPosX = positionX + (newPositionX - positionX) * step;\n        var newPosY = positionY + (newPositionY - positionY) * step;\n        var newScale = scale + (targetScale - scale) * step;\n        _this.stateProvider = _extends({}, _this.stateProvider, {\n          positionX: newPosX,\n          positionY: newPosY,\n          scale: newScale,\n          previousScale: scale\n        }); // update component transformation\n\n        _this.setContentComponentTransformation();\n      },\n      doneCallback: function doneCallback() {\n        if (animationTime !== \"wheel\") {\n          handleCallback(_this.props.onZoomChange, _this.getCallbackProps());\n        }\n      },\n      cancelCallback: function cancelCallback() {\n        if (animationTime !== \"wheel\") {\n          handleCallback(_this.props.onZoomChange, _this.getCallbackProps());\n        }\n      }\n    };\n\n    if (disabledPadding) {\n      animatePaddingFunction.bind(this, params)();\n    } else {\n      animateFunction.bind(this, params)();\n    }\n  }\n}\n\nfunction handleZoomControls(event, customDelta, customStep) {\n  var _stateProvider4 = this.stateProvider,\n      positionX = _stateProvider4.positionX,\n      positionY = _stateProvider4.positionY,\n      scale = _stateProvider4.scale,\n      zoomInAnimationSpeed = _stateProvider4.zoomInAnimationSpeed,\n      zoomOutAnimationSpeed = _stateProvider4.zoomOutAnimationSpeed;\n  var wrapperComponent = this.state.wrapperComponent; // calculate zoom center\n\n  var wrapperWidth = wrapperComponent.offsetWidth;\n  var wrapperHeight = wrapperComponent.offsetHeight;\n  var mouseX = (Math.abs(positionX) + wrapperWidth / 2) / scale;\n  var mouseY = (Math.abs(positionY) + wrapperHeight / 2) / scale;\n  var animationSpeed = customDelta ? zoomInAnimationSpeed : zoomOutAnimationSpeed;\n  handleZoom.bind(this, event, {\n    mouseX: mouseX,\n    mouseY: mouseY\n  }, customDelta, customStep, animationSpeed)();\n}\n\nfunction handleZoomDbClick(event) {\n  var _stateProvider5 = this.stateProvider,\n      dbClickMode = _stateProvider5.dbClickMode,\n      dbClickStep = _stateProvider5.dbClickStep,\n      dbClickAnimationSpeed = _stateProvider5.dbClickAnimationSpeed;\n\n  if (dbClickMode === \"reset\") {\n    return resetTransformations.bind(this, event, dbClickAnimationSpeed)();\n  }\n\n  var delta = dbClickMode === \"zoomOut\" ? -1 : 1;\n  handleZoom.bind(this, event, null, delta, dbClickStep, dbClickAnimationSpeed)();\n}\n\nfunction resetTransformations() {\n  var _this2 = this;\n\n  var _props$defaultValues = this.props.defaultValues,\n      defaultScale = _props$defaultValues.defaultScale,\n      defaultPositionX = _props$defaultValues.defaultPositionX,\n      defaultPositionY = _props$defaultValues.defaultPositionY;\n  var _stateProvider6 = this.stateProvider,\n      scale = _stateProvider6.scale,\n      positionX = _stateProvider6.positionX,\n      positionY = _stateProvider6.positionY,\n      disabled = _stateProvider6.disabled,\n      resetAnimationSpeed = _stateProvider6.resetAnimationSpeed;\n  if (disabled) return;\n  if (scale === defaultScale && positionX === defaultPositionX && positionY === defaultPositionY) return;\n  var targetScale = checkIsNumber(defaultScale, initialState.scale);\n  var newPositionX = checkIsNumber(defaultPositionX, initialState.positionX);\n  var newPositionY = checkIsNumber(defaultPositionY, initialState.positionY); // animate\n\n  animateFunction.bind(this, {\n    animationVariable: this.animate,\n    animationTime: resetAnimationSpeed,\n    animationName: \"linear\",\n    callback: function callback(step) {\n      var newPosX = positionX + (newPositionX - positionX) * step;\n      var newPosY = positionY + (newPositionY - positionY) * step;\n      var newScale = scale + (targetScale - scale) * step;\n      _this2.stateProvider = _extends({}, _this2.stateProvider, {\n        scale: newScale,\n        positionX: newPosX,\n        positionY: newPosY,\n        previousScale: _this2.stateProvider.scale\n      }); // update component transformation\n\n      _this2.setContentComponentTransformation();\n    },\n    doneCallback: function doneCallback() {\n      handleCallback(_this2.props.onZoomChange, _this2.getCallbackProps());\n    },\n    cancelCallback: function cancelCallback() {\n      handleCallback(_this2.props.onZoomChange, _this2.getCallbackProps());\n    }\n  })();\n}\n\nfunction animatePadding(event) {\n  var _stateProvider7 = this.stateProvider,\n      positionX = _stateProvider7.positionX,\n      positionY = _stateProvider7.positionY,\n      scale = _stateProvider7.scale,\n      scalePaddingAnimationSpeed = _stateProvider7.scalePaddingAnimationSpeed,\n      minScale = _stateProvider7.minScale,\n      maxScale = _stateProvider7.maxScale;\n  if (scale > minScale && scale < maxScale) return;\n  var wrapperComponent = this.state.wrapperComponent; // calculate zoom center\n\n  var wrapperWidth = wrapperComponent.offsetWidth;\n  var wrapperHeight = wrapperComponent.offsetHeight;\n  var mouseX = (Math.abs(positionX) + wrapperWidth / 2) / scale;\n  var mouseY = (Math.abs(positionY) + wrapperHeight / 2) / scale;\n  handleZoom.bind(this, event, {\n    mouseX: mouseX,\n    mouseY: mouseY\n  }, this.lastDelta, 1, scalePaddingAnimationSpeed, true)();\n}\n\nfunction round(number, decimal) {\n  var roundNumber$$1 = Math.pow(10, decimal);\n  return Math.round(number * roundNumber$$1) / roundNumber$$1;\n}\n\nfunction getCurrentDistance(event) {\n  return getDistance(event.touches[0], event.touches[1]);\n}\n\nfunction checkIfInfinite(number) {\n  return number === Infinity || number === -Infinity;\n}\n\nfunction calculatePinchZoom(currentDistance, pinchStartDistance) {\n  var _stateProvider = this.stateProvider,\n      minScale = _stateProvider.minScale,\n      maxScale = _stateProvider.maxScale,\n      scaleAnimationPadding = _stateProvider.scaleAnimationPadding;\n  if (typeof pinchStartDistance !== \"number\" || typeof currentDistance !== \"number\") return console.error(\"Pinch touches distance was not provided\");\n  if (currentDistance < 0) return;\n  var touchProportion = currentDistance / pinchStartDistance;\n  var scaleDifference = touchProportion * this.pinchStartScale;\n  return checkZoomBounds(scaleDifference, minScale, maxScale, scaleAnimationPadding);\n}\n\nfunction calculateMidpoint(event, scale, contentComponent) {\n  var contentRect = contentComponent.getBoundingClientRect();\n  var touches = event.touches;\n  var firstPointX = round(touches[0].clientX - contentRect.left, 5);\n  var firstPointY = round(touches[0].clientY - contentRect.top, 5);\n  var secondPointX = round(touches[1].clientX - contentRect.left, 5);\n  var secondPointY = round(touches[1].clientY - contentRect.top, 5);\n  return {\n    mouseX: (firstPointX + secondPointX) / 2 / scale,\n    mouseY: (firstPointY + secondPointY) / 2 / scale\n  };\n}\n\nfunction handleZoomPinch(event) {\n  var _stateProvider2 = this.stateProvider,\n      isDown = _stateProvider2.isDown,\n      zoomingEnabled = _stateProvider2.zoomingEnabled,\n      disabled = _stateProvider2.disabled,\n      scale = _stateProvider2.scale,\n      limitToWrapperBounds = _stateProvider2.limitToWrapperBounds;\n  var _state = this.state,\n      wrapperComponent = _state.wrapperComponent,\n      contentComponent = _state.contentComponent;\n  if (isDown || !zoomingEnabled || disabled) return;\n\n  if (event.cancelable) {\n    event.preventDefault();\n    event.stopPropagation();\n  } // if one finger starts from outside of wrapper\n\n\n  if (this.pinchStartDistance === null) return; // Position transformation\n\n  var _calculateMidpoint = calculateMidpoint(event, scale, contentComponent),\n      mouseX = _calculateMidpoint.mouseX,\n      mouseY = _calculateMidpoint.mouseY; // if touches goes off of the wrapper element\n\n\n  if (checkIfInfinite(mouseX) || checkIfInfinite(mouseY)) return;\n  var currentDistance = getCurrentDistance(event);\n  var newScale = calculatePinchZoom.bind(this, currentDistance, this.pinchStartDistance)();\n  if (checkIfInfinite(newScale) || newScale === scale) return;\n  var scaleDifference = newScale - scale; // Get new element sizes to calculate bounds\n\n  var _getComponentsSizes = getComponentsSizes(wrapperComponent, newScale),\n      wrapperWidth = _getComponentsSizes.wrapperWidth,\n      wrapperHeight = _getComponentsSizes.wrapperHeight,\n      newContentWidth = _getComponentsSizes.newContentWidth,\n      newDiffWidth = _getComponentsSizes.newDiffWidth,\n      newContentHeight = _getComponentsSizes.newContentHeight,\n      newDiffHeight = _getComponentsSizes.newDiffHeight;\n\n  var bounds = calculateBoundingArea(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, limitToWrapperBounds); // Save last zoom bounds, to speed up panning function\n\n  this.bounds = bounds; // Calculate transformations\n\n  var _calculateTransformat = calculateTransformation.bind(this, mouseX, mouseY, scaleDifference, bounds)(),\n      newPositionX = _calculateTransformat.newPositionX,\n      newPositionY = _calculateTransformat.newPositionY;\n\n  this.lastDistance = currentDistance;\n  this.stateProvider = _extends({}, this.stateProvider, {\n    positionX: newPositionX,\n    positionY: newPositionY,\n    scale: newScale,\n    previousScale: scale\n  }); // update component transformation\n\n  this.setContentComponentTransformation();\n}\n\nfunction getSizes(wrapperComponent, contentComponent) {\n  var wrapperRect = wrapperComponent.getBoundingClientRect();\n  var contentRect = contentComponent.getBoundingClientRect();\n  var wrapperWidth = wrapperRect.width;\n  var wrapperHeight = wrapperRect.height;\n  var contentWidth = contentRect.width;\n  var contentHeight = contentRect.height;\n  var diffWidth = wrapperWidth - contentWidth;\n  var diffHeight = wrapperHeight - contentHeight;\n  return {\n    wrapperWidth: wrapperWidth,\n    wrapperHeight: wrapperHeight,\n    contentWidth: contentWidth,\n    diffWidth: diffWidth,\n    contentHeight: contentHeight,\n    diffHeight: diffHeight\n  };\n}\n\nfunction handleCalculateBounds(wrapperComponent, contentComponent, limitToWrapperBounds) {\n  var _getSizes = getSizes(wrapperComponent, contentComponent),\n      wrapperWidth = _getSizes.wrapperWidth,\n      contentWidth = _getSizes.contentWidth,\n      diffWidth = _getSizes.diffWidth,\n      wrapperHeight = _getSizes.wrapperHeight,\n      contentHeight = _getSizes.contentHeight,\n      diffHeight = _getSizes.diffHeight;\n\n  return calculateBoundingArea(wrapperWidth, contentWidth, diffWidth, wrapperHeight, contentHeight, diffHeight, limitToWrapperBounds);\n}\n\nfunction getClientPosition(event) {\n  var touches = event.touches; // Mobile points\n\n  if (touches && touches.length === 1) {\n    return {\n      clientX: touches[0].clientX,\n      clientY: touches[0].clientY\n    };\n  } // Desktop points\n\n\n  if (!touches) {\n    return {\n      clientX: event.clientX,\n      clientY: event.clientY\n    };\n  }\n\n  return null;\n}\n\nfunction handlePanning(event) {\n  var _stateProvider = this.stateProvider,\n      limitToWrapperBounds = _stateProvider.limitToWrapperBounds,\n      limitToBounds = _stateProvider.limitToBounds,\n      positionX = _stateProvider.positionX,\n      positionY = _stateProvider.positionY,\n      lockAxisX = _stateProvider.lockAxisX,\n      lockAxisY = _stateProvider.lockAxisY;\n  var _state = this.state,\n      wrapperComponent = _state.wrapperComponent,\n      contentComponent = _state.contentComponent;\n  if (!this.startCoords) return;\n  var _startCoords = this.startCoords,\n      x = _startCoords.x,\n      y = _startCoords.y;\n  var positions = getClientPosition(event);\n  if (!positions) return console.error(\"Cannot find mouse client positions\");\n  var clientX = positions.clientX,\n      clientY = positions.clientY; // Calculate bounding area\n\n  var bounds = this.bounds; // If panning is fired before scaling and there are no bounds calculated\n\n  if (!bounds) {\n    var calculatedBounds = handleCalculateBounds(wrapperComponent, contentComponent, limitToWrapperBounds);\n    this.bounds = calculatedBounds;\n    bounds = calculatedBounds;\n  } // Get Position\n\n\n  var newPositionX = lockAxisX ? positionX : clientX - x;\n  var newPositionY = lockAxisY ? positionY : clientY - y; // If position didn't change\n\n  if (newPositionX === positionX && newPositionY === positionY) return;\n  var calculatedPosition = checkPositionBounds(newPositionX, newPositionY, bounds, limitToBounds); // Save panned position\n\n  this.stateProvider = _extends({}, this.stateProvider, {\n    positionX: calculatedPosition.x,\n    positionY: calculatedPosition.y\n  }); // update component transformation\n\n  this.setContentComponentTransformation();\n}\n\nfunction velocityTimeSpeed(speed, animationTime) {\n  var velocityTimeBasedOnMove = this.stateProvider.velocityTimeBasedOnMove;\n\n  if (velocityTimeBasedOnMove) {\n    return animationTime - animationTime / Math.max(1.6, speed);\n  }\n\n  return animationTime;\n}\n\nfunction handleEnableVelocity() {\n  this.setState({\n    startAnimation: false\n  });\n}\n\nfunction handleFireVelocity() {\n  this.setState({\n    startAnimation: true\n  });\n}\n\nfunction animateVelocity() {\n  var _this = this;\n\n  var _stateProvider = this.stateProvider,\n      positionX = _stateProvider.positionX,\n      positionY = _stateProvider.positionY,\n      limitToBounds = _stateProvider.limitToBounds,\n      velocityAnimationSpeed = _stateProvider.velocityAnimationSpeed,\n      lockAxisX = _stateProvider.lockAxisX,\n      lockAxisY = _stateProvider.lockAxisY;\n  if (!this.velocity || !this.bounds) return handleDisableAnimation.bind(this)();\n  var _velocity = this.velocity,\n      velocityX = _velocity.velocityX,\n      velocityY = _velocity.velocityY,\n      velocity = _velocity.velocity;\n  var animationTime = velocityTimeSpeed.bind(this, velocity, velocityAnimationSpeed)();\n  var targetX = velocityX;\n  var targetY = velocityY;\n  this.offsetX = positionX;\n  this.offsetY = positionY;\n  animateFunction.bind(this, {\n    animationVariable: this.animate,\n    animationTime: animationTime,\n    callback: function callback(step) {\n      var currentPositionX = lockAxisX ? positionX : _this.offsetX + targetX - targetX * step;\n      var currentPositionY = lockAxisY ? positionY : _this.offsetY + targetY - targetY * step;\n      var calculatedPosition = checkPositionBounds(currentPositionX, currentPositionY, _this.bounds, limitToBounds);\n      _this.offsetX = calculatedPosition.x;\n      _this.offsetY = calculatedPosition.y; // Save panned position\n\n      _this.stateProvider = _extends({}, _this.stateProvider, {\n        positionX: calculatedPosition.x,\n        positionY: calculatedPosition.y\n      }); // update component transformation\n\n      _this.setContentComponentTransformation();\n    },\n    doneCallback: function doneCallback() {\n      return handleDisableAnimation.bind(_this)();\n    },\n    cancelCallback: function cancelCallback() {\n      return _this.velocity = null;\n    }\n  })();\n}\n\nfunction calculateVelocityStart(event) {\n  var _this2 = this;\n\n  var _stateProvider2 = this.stateProvider,\n      enableVelocity = _stateProvider2.enableVelocity,\n      minVelocityScale = _stateProvider2.minVelocityScale,\n      scale = _stateProvider2.scale,\n      disabled = _stateProvider2.disabled,\n      velocitySensitivity = _stateProvider2.velocitySensitivity;\n  if (!enableVelocity || minVelocityScale >= scale || disabled) return;\n  handleEnableVelocity.bind(this)();\n  var now = Date.now();\n\n  if (this.lastMousePosition) {\n    var _position = getClientPosition(event);\n\n    if (!_position) return console.error(\"No mouse or touch position detected\");\n    var clientX = _position.clientX,\n        clientY = _position.clientY;\n    var distanceX = (clientX - this.lastMousePosition.clientX) * scale;\n    var distanceY = (clientY - this.lastMousePosition.clientY) * scale;\n    var interval = now - this.velocityTime;\n    var velocityX = distanceX / interval * velocitySensitivity;\n    var velocityY = distanceY / interval * velocitySensitivity;\n    var velocity = Math.sqrt(distanceX * distanceX + distanceY * distanceY) / interval * velocitySensitivity;\n    if (this.velocity && velocity < this.velocity.velocity && this.throttle) return;\n    this.velocity = {\n      velocityX: velocityX,\n      velocityY: velocityY,\n      velocity: velocity\n    }; // throttling\n\n    if (this.throttle) clearTimeout(this.throttle);\n    this.throttle = setTimeout(function () {\n      return _this2.throttle = false;\n    }, this.throttleTime);\n  }\n\n  var position = getClientPosition(event);\n  this.lastMousePosition = position;\n  this.velocityTime = now;\n} // We want to make event listeners non-passive, and to do so have to check\n\n\nfunction makePassiveEventOption(passive) {\n  return passive;\n}\n\nvar Context = React.createContext({});\nvar timer = null;\nvar timerTime = 100;\nvar wheelTimer = null;\nvar wheelTime = 50;\n\nvar StateProvider = function (_Component) {\n  inherits(StateProvider, _Component);\n\n  function StateProvider() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StateProvider);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StateProvider.__proto__ || Object.getPrototypeOf(StateProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      wrapperComponent: null,\n      contentComponent: null,\n      startAnimation: false\n    }, _this.stateProvider = _extends({}, initialState, _this.props.dynamicValues, _this.props.defaultValues, {\n      previousScale: _this.props.defaultValues.scale || initialState.scale\n    }), _this.pinchStartDistance = null, _this.lastDistance = null, _this.pinchStartScale = null, _this.distance = null, _this.bounds = null, _this.startPanningCoords = null, _this.velocityTime = null, _this.lastMousePosition = null, _this.velocity = null, _this.animate = false, _this.offsetX = null, _this.offsetY = null, _this.throttle = false, _this.throttleTime = 30, _this.zoomPaddingAnimation = null, _this.zoomPaddingTimer = null, _this.wheelEnd = false, _this.lastWheelScale = null, _this.lastWheelDelta = null, _this.handleWheel = function (event) {\n      var _this$stateProvider = _this.stateProvider,\n          enableWheel = _this$stateProvider.enableWheel,\n          enableTouchPadPinch = _this$stateProvider.enableTouchPadPinch,\n          scale = _this$stateProvider.scale,\n          maxScale = _this$stateProvider.maxScale,\n          minScale = _this$stateProvider.minScale;\n      var _this$props = _this.props,\n          onWheelStart = _this$props.onWheelStart,\n          onWheel = _this$props.onWheel,\n          onWheelStop = _this$props.onWheelStop,\n          onZoomChange = _this$props.onZoomChange; // ctrlKey detects if touchpad execute wheel or pinch gesture\n\n      if (!enableWheel && !event.ctrlKey) return;\n      if (!enableTouchPadPinch && event.ctrlKey) return;\n\n      if (scale != _this.lastWheelScale) {\n        _this.wheelStart = false;\n        _this.lastWheelScale = scale;\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n          animatePadding.bind(_this, event)();\n          handleCallback(onWheelStop, _this.getCallbackProps());\n          handleCallback(onZoomChange, _this.getCallbackProps());\n          timer = null;\n          _this.lastWheelScale = null;\n          _this.wheelEnd = true;\n        }, timerTime);\n      }\n\n      if (!_this.lastWheelDelta) _this.lastWheelDelta = event.deltaY;\n\n      if (_this.wheelEnd) {\n        if (Math.abs(event.deltaY) <= Math.abs(_this.lastWheelDelta)) {\n          clearTimeout(wheelTimer);\n          wheelTimer = setTimeout(function () {\n            wheelTimer = null;\n            _this.wheelEnd = false;\n            _this.lastWheelDelta = null;\n          }, wheelTime);\n          _this.lastWheelDelta = event.deltaY;\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n        return;\n      }\n\n      if (!timer) {\n        // Wheel start event\n        handleDisableAnimation.bind(_this)();\n        handleCallback(onWheelStart, _this.getCallbackProps());\n      } // Wheel event\n\n\n      handleZoom.bind(_this, event, undefined, undefined, undefined, \"wheel\")();\n      handleCallback(onWheel, _this.getCallbackProps()); // Wheel stop event\n\n      if (scale > maxScale || scale < minScale) {\n        clearTimeout(_this.zoomPaddingTimer);\n        _this.zoomPaddingTimer = setTimeout(function () {}, 10);\n      }\n    }, _this.checkIsPanningActive = function (event) {\n      var _this$stateProvider2 = _this.stateProvider,\n          panningEnabled = _this$stateProvider2.panningEnabled,\n          disabled = _this$stateProvider2.disabled;\n      return !_this.isDown || !panningEnabled || disabled || event.touches && (event.touches.length !== 1 || Math.abs(_this.startCoords.x - event.touches[0].clientX) < 1);\n    }, _this.handleSetUpPanning = function (x, y) {\n      var _this$stateProvider3 = _this.stateProvider,\n          positionX = _this$stateProvider3.positionX,\n          positionY = _this$stateProvider3.positionY;\n      _this.isDown = true;\n      _this.startCoords = {\n        x: x - positionX,\n        y: y - positionY\n      };\n      handleCallback(_this.props.onPanningStart, _this.getCallbackProps());\n    }, _this.handleStartPanning = function (event) {\n      var _this$stateProvider4 = _this.stateProvider,\n          panningEnabled = _this$stateProvider4.panningEnabled,\n          disabled = _this$stateProvider4.disabled,\n          wrapperComponent = _this$stateProvider4.wrapperComponent;\n      var target = event.target,\n          touches = event.touches;\n      if (!panningEnabled || disabled || wrapperComponent && !wrapperComponent.contains(target)) return;\n      handleDisableAnimation.bind(_this)(); // Mobile points\n\n      if (touches && touches.length === 1) {\n        _this.handleSetUpPanning(touches[0].clientX, touches[0].clientY);\n      } // Desktop points\n\n\n      if (!touches) {\n        _this.handleSetUpPanning(event.clientX, event.clientY);\n      }\n    }, _this.handlePanning = function (event) {\n      event.preventDefault();\n      if (_this.checkIsPanningActive(event)) return;\n      event.stopPropagation();\n      calculateVelocityStart.bind(_this, event)();\n      handlePanning.bind(_this, event)();\n      handleCallback(_this.props.onPanning, _this.getCallbackProps());\n    }, _this.handleStopPanning = function () {\n      if (_this.isDown) {\n        _this.isDown = false;\n        handleFireVelocity.bind(_this)();\n        handleCallback(_this.props.onPanningStop, _this.getCallbackProps());\n      }\n    }, _this.handlePinchStart = function (event) {\n      var scale = _this.stateProvider.scale;\n      event.preventDefault();\n      event.stopPropagation();\n      handleDisableAnimation.bind(_this)();\n      var distance = getDistance(event.touches[0], event.touches[1]);\n      _this.pinchStartDistance = distance;\n      _this.lastDistance = distance;\n      _this.pinchStartScale = scale;\n      handleCallback(_this.props.onPinchingStart, _this.getCallbackProps());\n    }, _this.handlePinch = function (event) {\n      handleZoomPinch.bind(_this, event)();\n      handleCallback(_this.props.onPinching, _this.getCallbackProps());\n    }, _this.handlePinchStop = function (event) {\n      if (typeof _this.pinchStartScale === \"number\") {\n        _this.pinchStartDistance = null;\n        _this.lastDistance = null;\n        _this.pinchStartScale = null;\n        animatePadding.bind(_this, event)();\n        handleCallback(_this.props.onPinchingStop, _this.getCallbackProps());\n      }\n    }, _this.handleTouchStart = function (event) {\n      var disabled = _this.stateProvider.disabled;\n      var touches = event.touches;\n      handleDisableAnimation.bind(_this)();\n      if (disabled) return;\n      if (touches && touches.length === 1) return _this.handleStartPanning(event);\n      if (touches && touches.length === 2) return _this.handlePinchStart(event);\n    }, _this.handleTouch = function (event) {\n      var _this$stateProvider5 = _this.stateProvider,\n          panningEnabled = _this$stateProvider5.panningEnabled,\n          pinchEnabled = _this$stateProvider5.pinchEnabled,\n          disabled = _this$stateProvider5.disabled;\n      if (disabled) return;\n      if (panningEnabled && event.touches.length === 1) return _this.handlePanning(event);\n      if (pinchEnabled && event.touches.length === 2) return _this.handlePinch(event);\n    }, _this.handleTouchStop = function (event) {\n      _this.handlePinchStop(event);\n\n      _this.handleStopPanning();\n    }, _this.resetLastMousePosition = function () {\n      return _this.stateProvider = _extends({}, _this.stateProvider, {\n        lastMouseEventPosition: null\n      });\n    }, _this.zoomIn = function (event) {\n      var _this$stateProvider6 = _this.stateProvider,\n          zoomingEnabled = _this$stateProvider6.zoomingEnabled,\n          disabled = _this$stateProvider6.disabled,\n          zoomInStep = _this$stateProvider6.zoomInStep;\n      if (!event) throw Error(\"Zoom in function require event prop\");\n      if (!zoomingEnabled || disabled) return;\n      handleZoomControls.bind(_this, event, 1, zoomInStep)();\n    }, _this.zoomOut = function (event) {\n      var _this$stateProvider7 = _this.stateProvider,\n          zoomingEnabled = _this$stateProvider7.zoomingEnabled,\n          disabled = _this$stateProvider7.disabled,\n          zoomOutStep = _this$stateProvider7.zoomOutStep;\n      if (!event) throw Error(\"Zoom out function require event prop\");\n      if (!zoomingEnabled || disabled) return;\n      handleZoomControls.bind(_this, event, -1, zoomOutStep)();\n    }, _this.handleDbClick = function (event) {\n      var _this$stateProvider8 = _this.stateProvider,\n          zoomingEnabled = _this$stateProvider8.zoomingEnabled,\n          disabled = _this$stateProvider8.disabled,\n          dbClickStep = _this$stateProvider8.dbClickStep,\n          dbClickEnabled = _this$stateProvider8.dbClickEnabled;\n      if (!event) throw Error(\"Double click function require event prop\");\n      if (!zoomingEnabled || disabled || !dbClickEnabled) return;\n      handleZoomDbClick.bind(_this, event, 1, dbClickStep)();\n    }, _this.setScale = function (scale) {\n      _this.stateProvider = _extends({}, _this.stateProvider, {\n        scale: scale\n      }); // update component transformation\n\n      _this.setContentComponentTransformation();\n    }, _this.setPositionX = function (positionX) {\n      _this.stateProvider = _extends({}, _this.stateProvider, {\n        positionX: roundNumber(positionX, 3)\n      }); // update component transformation\n\n      _this.setContentComponentTransformation();\n    }, _this.setPositionY = function (positionY) {\n      _this.stateProvider = _extends({}, _this.stateProvider, {\n        positionY: roundNumber(positionY, 3)\n      }); // update component transformation\n\n      _this.setContentComponentTransformation();\n    }, _this.setTransform = function (positionX, positionY, scale) {\n      if (!_this.stateProvider.transformEnabled) return;\n      !isNaN(scale) && _this.setScale(scale);\n      !isNaN(positionX) && _this.setPositionX(positionX);\n      !isNaN(positionY) && _this.setPositionY(positionY);\n    }, _this.resetTransform = function () {\n      var disabled = _this.stateProvider.disabled;\n      if (disabled) return;\n      resetTransformations.bind(_this)();\n    }, _this.setWrapperComponent = function (wrapperComponent) {\n      _this.setState({\n        wrapperComponent: wrapperComponent\n      });\n    }, _this.setContentComponent = function (contentComponent) {\n      _this.setState({\n        contentComponent: contentComponent\n      }, function () {\n        if (_this.stateProvider.isCentered) {\n          var scale = _this.stateProvider.scale;\n\n          var rect = _this.state.wrapperComponent.getBoundingClientRect();\n\n          _this.stateProvider.positionX = (rect.width - rect.width * scale) / 2;\n          _this.stateProvider.positionY = (rect.height - rect.height * scale) / 2;\n        }\n\n        _this.setContentComponentTransformation();\n      });\n    }, _this.setContentComponentTransformation = function () {\n      var contentComponent = _this.state.contentComponent;\n      if (!contentComponent) return console.error(\"There is no content component\");\n      var transform = \"translate(\" + _this.stateProvider.positionX + \"px, \" + _this.stateProvider.positionY + \"px) scale(\" + _this.stateProvider.scale + \")\";\n      contentComponent.style.transform = transform;\n\n      _this.setState({\n        updated: true\n      });\n    }, _this.getCallbackProps = function () {\n      return {\n        positionX: _this.stateProvider.positionX,\n        positionY: _this.stateProvider.positionY,\n        scale: _this.stateProvider.scale,\n        sensitivity: _this.stateProvider.sensitivity,\n        maxScale: _this.stateProvider.maxScale,\n        minScale: _this.stateProvider.minScale,\n        wheelAnimationSpeed: _this.stateProvider.wheelAnimationSpeed,\n        zoomAnimationSpeed: _this.stateProvider.zoomAnimationSpeed,\n        pinchAnimationSpeed: _this.stateProvider.pinchAnimationSpeed,\n        panAnimationSpeed: _this.stateProvider.panAnimationSpeed,\n        minPositionX: _this.stateProvider.minPositionX,\n        minPositionY: _this.stateProvider.minPositionY,\n        maxPositionX: _this.stateProvider.maxPositionX,\n        maxPositionY: _this.stateProvider.maxPositionY,\n        limitToBounds: _this.stateProvider.limitToBounds,\n        zoomingEnabled: _this.stateProvider.zoomingEnabled,\n        panningEnabled: _this.stateProvider.panningEnabled,\n        transformEnabled: _this.stateProvider.transformEnabled,\n        pinchEnabled: _this.stateProvider.pinchEnabled,\n        limitToWrapperBounds: _this.stateProvider.limitToWrapperBounds,\n        disabled: _this.stateProvider.disabled,\n        zoomOutStep: _this.stateProvider.zoomOutStep,\n        zoomInStep: _this.stateProvider.zoomInStep,\n        dbClickStep: _this.stateProvider.dbClickStep,\n        pinchSensitivity: _this.stateProvider.pinchSensitivity,\n        dbClickEnabled: _this.stateProvider.dbClickEnabled,\n        lastPositionZoomEnabled: _this.stateProvider.lastPositionZoomEnabled,\n        previousScale: _this.stateProvider.previousScale,\n        scaleAnimationPadding: _this.stateProvider.scalePadding,\n        lockAxisX: _this.stateProvider.lockAxisX,\n        lockAxisY: _this.stateProvider.lockAxisY,\n        velocityTimeBasedOnMove: _this.stateProvider.velocityTimeBasedOnMove,\n        velocitySensitivity: _this.stateProvider.velocitySensitivity,\n        scalePaddingAnimationSpeed: _this.stateProvider.scalePaddingAnimationSpeed,\n        enableWheel: _this.stateProvider.enableWheel,\n        enableTouchPadPinch: _this.stateProvider.enableTouchPadPinch\n      };\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  } // pinch helpers\n  // velocity helpers\n  // zoom helpers\n  // wheel helpers\n\n\n  createClass(StateProvider, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var passiveOption = makePassiveEventOption(false); // Panning on window to allow panning when mouse is out of wrapper\n\n      window.addEventListener(\"mousedown\", this.handleStartPanning, passiveOption);\n      window.addEventListener(\"mousemove\", this.handlePanning, passiveOption);\n      window.addEventListener(\"mouseup\", this.handleStopPanning, passiveOption);\n      return function () {\n        window.removeEventListener(\"mousedown\", _this2.handleStartPanning, passiveOption);\n        window.removeEventListener(\"mousemove\", _this2.handlePanning, passiveOption);\n        window.removeEventListener(\"mouseup\", _this2.handleStopPanning, passiveOption);\n      };\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(oldProps, oldState) {\n      var _state = this.state,\n          wrapperComponent = _state.wrapperComponent,\n          contentComponent = _state.contentComponent,\n          startAnimation = _state.startAnimation;\n      var dynamicValues = this.props.dynamicValues;\n\n      if (!oldState.contentComponent && contentComponent) {\n        this.stateProvider = _extends({}, this.stateProvider, {\n          contentComponent: contentComponent\n        });\n      }\n\n      if (!oldState.wrapperComponent && wrapperComponent) {\n        this.stateProvider = _extends({}, this.stateProvider, {\n          wrapperComponent: wrapperComponent\n        }); // Zooming events on wrapper\n\n        var passiveOption = makePassiveEventOption(false);\n        wrapperComponent.addEventListener(\"mousewheel\", this.handleWheel, passiveOption);\n        wrapperComponent.addEventListener(\"dblclick\", this.handleDbClick, passiveOption);\n        wrapperComponent.addEventListener(\"touchstart\", this.handleTouchStart, passiveOption);\n        wrapperComponent.addEventListener(\"touchmove\", this.handleTouch, passiveOption);\n        wrapperComponent.addEventListener(\"touchend\", this.handleTouchStop, passiveOption);\n      } // start velocity animation\n\n\n      if (this.velocity && startAnimation) animateVelocity.bind(this)(); // when bounds limiters change\n\n      if (oldProps.dynamicValues !== dynamicValues && (oldProps.dynamicValues.limitToBounds !== dynamicValues.limitToBounds || oldProps.dynamicValues.limitToWrapperBounds !== dynamicValues.limitToWrapperBounds)) {\n        this.bounds = null;\n      } // must be at the end of the update function\n\n\n      if (oldProps.dynamicValues !== dynamicValues) {\n        this.stateProvider = _extends({}, this.stateProvider, dynamicValues);\n        this.forceUpdate();\n      }\n    } //////////\n    // Wheel\n    //////////\n    //////////\n    // Panning\n    //////////\n    //////////\n    // Pinch\n    //////////\n    //////////\n    // Touch Events\n    //////////\n    //////////\n    // Controls\n    //////////\n    //////////\n    // Setters\n    //////////\n    //////////\n    // Props\n    //////////\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      /**\n       * Context provider value\n       */\n      var value = {\n        state: this.getCallbackProps(),\n        dispatch: {\n          setScale: this.setScale,\n          setPositionX: this.setPositionX,\n          setPositionY: this.setPositionY,\n          zoomIn: this.zoomIn,\n          zoomOut: this.zoomOut,\n          setTransform: this.setTransform,\n          resetTransform: this.resetTransform\n        },\n        nodes: {\n          setWrapperComponent: this.setWrapperComponent,\n          setContentComponent: this.setContentComponent\n        },\n        internal: {\n          handleZoom: this.handleZoom,\n          handleStartPanning: this.handleStartPanning,\n          handlePanning: this.handlePanning,\n          handleStopPanning: this.handleStopPanning,\n          handleDbClick: this.handleDbClick,\n          handleTouchStart: this.handleTouchStart,\n          handleTouch: this.handleTouch,\n          handleTouchStop: this.handleTouchStop\n        }\n      };\n      var children = this.props.children;\n      var content = typeof children === \"function\" ? children(_extends({}, value.state, value.dispatch)) : children;\n      return React.createElement(Context.Provider, {\n        value: value\n      }, content);\n    }\n  }]);\n  return StateProvider;\n}(Component);\n\nStateProvider.defaultProps = {\n  defaultValues: {},\n  dynamicValues: {},\n  onWheelStart: null,\n  onWheel: null,\n  onWheelStop: null,\n  onPanningStart: null,\n  onPanning: null,\n  onPanningStop: null,\n  onPinchingStart: null,\n  onPinching: null,\n  onPinchingStop: null\n};\nStateProvider.propTypes = {\n  children: PropTypes.any,\n  defaultValues: PropTypes.object,\n  dynamicValues: PropTypes.object,\n  onWheelStart: PropTypes.func,\n  onWheel: PropTypes.func,\n  onWheelStop: PropTypes.func,\n  onPanningStart: PropTypes.func,\n  onPanning: PropTypes.func,\n  onPanningStop: PropTypes.func,\n  onPinchingStart: PropTypes.func,\n  onPinching: PropTypes.func,\n  onPinchingStop: PropTypes.func,\n  onZoomChange: PropTypes.func\n};\n\nvar TransformWrapper = function TransformWrapper(_ref) {\n  var children = _ref.children,\n      scale = _ref.scale,\n      positionX = _ref.positionX,\n      positionY = _ref.positionY,\n      sensitivity = _ref.sensitivity,\n      maxScale = _ref.maxScale,\n      minScale = _ref.minScale,\n      scaleAnimationPadding = _ref.scaleAnimationPadding,\n      wheelAnimationSpeed = _ref.wheelAnimationSpeed,\n      zoomAnimationSpeed = _ref.zoomAnimationSpeed,\n      pinchAnimationSpeed = _ref.pinchAnimationSpeed,\n      panAnimationSpeed = _ref.panAnimationSpeed,\n      resetAnimationSpeed = _ref.resetAnimationSpeed,\n      scalePaddingAnimationSpeed = _ref.scalePaddingAnimationSpeed,\n      minPositionX = _ref.minPositionX,\n      minPositionY = _ref.minPositionY,\n      maxPositionX = _ref.maxPositionX,\n      maxPositionY = _ref.maxPositionY,\n      limitToBounds = _ref.limitToBounds,\n      zoomingEnabled = _ref.zoomingEnabled,\n      panningEnabled = _ref.panningEnabled,\n      transformEnabled = _ref.transformEnabled,\n      pinchEnabled = _ref.pinchEnabled,\n      limitToWrapperBounds = _ref.limitToWrapperBounds,\n      disabled = _ref.disabled,\n      zoomOutStep = _ref.zoomOutStep,\n      zoomInStep = _ref.zoomInStep,\n      dbClickStep = _ref.dbClickStep,\n      pinchSensitivity = _ref.pinchSensitivity,\n      dbClickEnabled = _ref.dbClickEnabled,\n      lastPositionZoomEnabled = _ref.lastPositionZoomEnabled,\n      enableZoomThrottling = _ref.enableZoomThrottling,\n      onWheelStart = _ref.onWheelStart,\n      onWheel = _ref.onWheel,\n      onWheelStop = _ref.onWheelStop,\n      onPanningStart = _ref.onPanningStart,\n      onPanning = _ref.onPanning,\n      onPanningStop = _ref.onPanningStop,\n      onPinchingStart = _ref.onPinchingStart,\n      onPinching = _ref.onPinching,\n      onPinchingStop = _ref.onPinchingStop,\n      onZoomChange = _ref.onZoomChange,\n      defaultPositionX = _ref.defaultPositionX,\n      defaultPositionY = _ref.defaultPositionY,\n      defaultScale = _ref.defaultScale,\n      lockAxisX = _ref.lockAxisX,\n      lockAxisY = _ref.lockAxisY,\n      velocityTimeBasedOnMove = _ref.velocityTimeBasedOnMove,\n      velocitySensitivity = _ref.velocitySensitivity,\n      isCentered = _ref.isCentered,\n      enableWheel = _ref.enableWheel,\n      enableTouchPadPinch = _ref.enableTouchPadPinch;\n  return React.createElement(StateProvider, {\n    defaultValues: deleteUndefinedProps({\n      positionX: defaultPositionX,\n      positionY: defaultPositionY,\n      scale: defaultScale\n    }),\n    dynamicValues: deleteUndefinedProps({\n      scale: scale,\n      positionX: positionX,\n      positionY: positionY,\n      sensitivity: sensitivity,\n      maxScale: maxScale,\n      minScale: minScale,\n      wheelAnimationSpeed: wheelAnimationSpeed,\n      zoomAnimationSpeed: zoomAnimationSpeed,\n      pinchAnimationSpeed: pinchAnimationSpeed,\n      panAnimationSpeed: panAnimationSpeed,\n      resetAnimationSpeed: resetAnimationSpeed,\n      minPositionX: minPositionX,\n      minPositionY: minPositionY,\n      maxPositionX: maxPositionX,\n      maxPositionY: maxPositionY,\n      limitToBounds: limitToBounds,\n      zoomingEnabled: zoomingEnabled,\n      panningEnabled: panningEnabled,\n      transformEnabled: transformEnabled,\n      pinchEnabled: pinchEnabled,\n      limitToWrapperBounds: limitToWrapperBounds,\n      disabled: disabled,\n      zoomOutStep: zoomOutStep,\n      zoomInStep: zoomInStep,\n      dbClickStep: dbClickStep,\n      pinchSensitivity: pinchSensitivity,\n      dbClickEnabled: dbClickEnabled,\n      lastPositionZoomEnabled: lastPositionZoomEnabled,\n      enableZoomThrottling: enableZoomThrottling,\n      lockAxisX: lockAxisX,\n      lockAxisY: lockAxisY,\n      velocityTimeBasedOnMove: velocityTimeBasedOnMove,\n      velocitySensitivity: velocitySensitivity,\n      scalePaddingAnimationSpeed: scalePaddingAnimationSpeed,\n      scaleAnimationPadding: scaleAnimationPadding,\n      isCentered: isCentered,\n      enableWheel: enableWheel,\n      enableTouchPadPinch: enableTouchPadPinch\n    }),\n    onWheelStart: onWheelStart,\n    onWheel: onWheel,\n    onWheelStop: onWheelStop,\n    onPanningStart: onPanningStart,\n    onPanning: onPanning,\n    onPanningStop: onPanningStop,\n    onPinchingStart: onPinchingStart,\n    onPinching: onPinching,\n    onPinchingStop: onPinchingStop,\n    onZoomChange: onZoomChange\n  }, children);\n};\n\nTransformWrapper.propTypes = {\n  children: PropTypes.any,\n  scale: PropTypes.number,\n  positionX: PropTypes.number,\n  positionY: PropTypes.number,\n  sensitivity: PropTypes.number,\n  maxScale: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n  minScale: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n  wheelAnimationSpeed: PropTypes.number,\n  zoomAnimationSpeed: PropTypes.number,\n  pinchAnimationSpeed: PropTypes.number,\n  panAnimationSpeed: PropTypes.number,\n  resetAnimationSpeed: PropTypes.number,\n  minPositionX: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n  maxPositionX: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n  minPositionY: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n  maxPositionY: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n  limitToBounds: PropTypes.bool,\n  zoomingEnabled: PropTypes.bool,\n  panningEnabled: PropTypes.bool,\n  transformEnabled: PropTypes.bool,\n  pinchEnabled: PropTypes.bool,\n  limitToWrapperBounds: PropTypes.bool,\n  disabled: PropTypes.bool,\n  zoomOutStep: PropTypes.bool,\n  zoomInStep: PropTypes.bool,\n  dbClickStep: PropTypes.bool,\n  pinchSensitivity: PropTypes.bool,\n  dbClickEnabled: PropTypes.bool,\n  lastPositionZoomEnabled: PropTypes.bool,\n  enableZoomThrottling: PropTypes.bool,\n  onWheelStart: PropTypes.func,\n  onWheel: PropTypes.func,\n  onWheelStop: PropTypes.func,\n  onPanningStart: PropTypes.func,\n  onPanning: PropTypes.func,\n  onPanningStop: PropTypes.func,\n  onPinchingStart: PropTypes.func,\n  onPinching: PropTypes.func,\n  onPinchingStop: PropTypes.func,\n  onZoomChange: PropTypes.func,\n  defaultPositionX: PropTypes.number,\n  defaultPositionY: PropTypes.number,\n  defaultScale: PropTypes.number,\n  lockAxisX: PropTypes.bool,\n  lockAxisY: PropTypes.bool,\n  velocityTimeBasedOnMove: PropTypes.bool,\n  velocitySensitivity: PropTypes.number,\n  scaleAnimationPadding: PropTypes.number,\n  scalePaddingAnimationSpeed: PropTypes.number,\n  isCentered: PropTypes.bool,\n  enableWheel: PropTypes.bool,\n  enableTouchPadPinch: PropTypes.bool\n};\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".TransformComponent-module_container__3NwNd {\\n  position: relative;\\n  width: fit-content;\\n  height: fit-content;\\n  overflow: hidden;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -khtml-user-select: none; /* Konqueror HTML */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n.TransformComponent-module_content__TZU5O {\\n  display: flex;\\n  flex-wrap: wrap;\\n  width: fit-content;\\n  height: fit-content;\\n  transform-origin: 0% 0%;\\n  margin: 0;\\n  padding: 0;\\n}\\n.TransformComponent-module_content__TZU5O img {\\n  pointer-events: none;\\n}\\n\";\nvar styles = {\n  \"container\": \"TransformComponent-module_container__3NwNd\",\n  \"content\": \"TransformComponent-module_content__TZU5O\"\n};\nstyleInject(css);\n\nfunction TransformComponent(_ref) {\n  var children = _ref.children;\n  var wrapperRef = useRef(null);\n  var contentRef = useRef(null);\n\n  var _useContext = useContext(Context),\n      state = _useContext.state,\n      nodes = _useContext.nodes;\n\n  var style = {\n    transform: \"translate(\" + state.positionX + \"px, \" + state.positionY + \"px) scale(\" + state.scale + \")\"\n  };\n  useEffect(function () {\n    if (wrapperRef.current) {\n      nodes.setWrapperComponent(wrapperRef.current);\n    }\n\n    if (contentRef.current) {\n      nodes.setContentComponent(contentRef.current);\n    }\n  }, []);\n  return React.createElement(\"div\", {\n    ref: wrapperRef,\n    className: \"\\\"react-transform-component\\\" \" + styles.container\n  }, React.createElement(\"div\", {\n    ref: contentRef,\n    className: \"react-transform-element \" + styles.content,\n    style: style\n  }, children));\n}\n\nTransformComponent.propTypes = {\n  children: PropTypes.any\n};\nexport { TransformWrapper, TransformComponent };","map":null,"metadata":{},"sourceType":"module"}