'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));

var initialState = {
  // components
  wrapperComponent: null,
  contentComponent: null,
  // settings
  limitToBounds: true,
  disabled: false,
  // position
  isCentered: true,
  transformEnabled: true,
  positionX: 0,
  positionY: 0,
  maxPositionX: null,
  minPositionX: null,
  maxPositionY: null,
  minPositionY: null,
  // scale
  zoomingEnabled: true,
  scale: 1,
  maxScale: 8,
  minScale: 1,
  previousScale: 1,
  scaleAnimationPadding: 0.15,
  // wheel
  wheelStep: 4,
  enableWheel: true,
  enableTouchPadPinch: true,
  // pinch
  pinchEnabled: true,
  pinchSensitivity: 1,
  startPinchDistance: null,
  //panning
  panningEnabled: true,
  limitToWrapperBounds: false,
  startPanningCoords: null,
  lockAxisX: false,
  lockAxisY: false,
  // velocity
  velocityTimeBasedOnMove: true,
  minVelocity: 1.8,
  enableVelocity: true,
  minVelocityScale: 1,
  // animations
  velocityAnimationSpeed: 1800,
  zoomAnimationSpeed: 200,
  velocitySensitivity: 1,
  // controls
  dbClickEnabled: true,
  dbClickMode: "zoomIn",
  zoomInStep: 40,
  zoomOutStep: 40,
  dbClickStep: 40,
  zoomInAnimationSpeed: 200,
  zoomOutAnimationSpeed: 200,
  dbClickAnimationSpeed: 200,
  resetAnimationSpeed: 200,
  scalePaddingAnimationSpeed: 200
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * Rounds number to given decimal
 * eg. roundNumber(2.34343, 1) => 2.3
 */
var roundNumber = function roundNumber(num) {
  var decimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

  return Number(num.toFixed(decimal));
};

/**
 * Checks if value is number, if not it returns default value
 * 1# eg. checkIsNumber(2, 30) => 2
 * 2# eg. checkIsNumber(null, 30) => 30
 */
var checkIsNumber = function checkIsNumber(num, defaultValue) {
  return typeof num === "number" ? num : defaultValue;
};

/**
 * Keeps value between given bounds, used for limiting view to given boundaries
 * 1# eg. boundLimiter(2, 0, 3, true) => 2
 * 2# eg. boundLimiter(4, 0, 3, true) => 3
 * 3# eg. boundLimiter(-2, 0, 3, true) => 0
 * 4# eg. boundLimiter(10, 0, 3, false) => 10
 */
var boundLimiter = function boundLimiter(value, minBound, maxBound, isActive) {
  if (!isActive) return roundNumber(value, 2);
  if (value < minBound) return roundNumber(minBound, 2);
  if (value > maxBound) return roundNumber(maxBound, 2);
  return roundNumber(value, 2);
};

/**
 * Calculate bounding area of zoomed/panned element
 */
var calculateBoundingArea = function calculateBoundingArea(wrapperWidth, contentWidth, diffWidth, wrapperHeight, contentHeight, diffHeight, limitToWrapperBounds) {
  var scaleWidthFactor = wrapperWidth > contentWidth ? diffWidth * (limitToWrapperBounds ? 1 : 0.5) : 0;
  var scaleHeightFactor = wrapperHeight > contentHeight ? diffHeight * (limitToWrapperBounds ? 1 : 0.5) : 0;

  var minPositionX = wrapperWidth - contentWidth - scaleWidthFactor;
  var maxPositionX = 0 + scaleWidthFactor;
  var minPositionY = wrapperHeight - contentHeight - scaleHeightFactor;
  var maxPositionY = 0 + scaleHeightFactor;

  return { minPositionX: minPositionX, maxPositionX: maxPositionX, minPositionY: minPositionY, maxPositionY: maxPositionY };
};

/**
 * Returns distance between two points x,y
 */
var getDistance = function getDistance(firstPoint, secondPoint) {
  return Math.sqrt(Math.pow(firstPoint.pageX - secondPoint.pageX, 2) + Math.pow(firstPoint.pageY - secondPoint.pageY, 2));
};

/**
 * Delete undefined values from object keys
 * Used for deleting empty props
 */

var deleteUndefinedProps = function deleteUndefinedProps(value) {
  var newObject = _extends({}, value);
  Object.keys(newObject).forEach(function (key) {
    return newObject[key] == undefined && delete newObject[key];
  });
  return newObject;
};

/**
 * Fire callback if it's function
 */

var handleCallback = function handleCallback(callback, props) {
  if (callback && typeof callback === "function") {
    callback(props);
  }
};

/**
 * Functions should return denominator of the target value, which is the next animation step.
 * animationProgress is a value from 0 to 1, reflecting the percentage of animation status.
 */
function easeOut(animationProgress) {
  return -Math.cos(animationProgress * Math.PI) / 2 + 0.5;
}
function easeIn(animationProgress) {
  return -Math.sin(animationProgress * Math.PI) / 2 + 0.5;
}
function linear(animationProgress) {
  return animationProgress;
}

function handleDisableAnimation() {
  this.velocity = null;
  this.animate = false;
  this.setState({ startAnimation: false });
}

function animateFunction(_ref) {
  var _this = this;

  var animationVariable = _ref.animationVariable,
      animationTime = _ref.animationTime,
      callback = _ref.callback,
      cancelCallback = _ref.cancelCallback,
      doneCallback = _ref.doneCallback,
      _ref$animationName = _ref.animationName,
      animationName = _ref$animationName === undefined ? "easeOut" : _ref$animationName;

  var lastStep = 1;
  if (this.animate) {
    cancelAnimationFrame(this.animate);
    cancelCallback();
  }
  var startTime = new Date().getTime();

  // if animation has only one step
  if (animationTime === 1) {
    callback(lastStep);
    doneCallback();
    this.animate = null;
    return;
  }
  this.animate = function () {
    if (!_this.animate) return;

    var frameTime = new Date().getTime() - startTime;
    var animationProgress = frameTime / animationTime;
    var animationType = {
      easeOut: easeOut,
      easeIn: easeIn,
      linear: linear
    }[animationName];
    var step = animationType(animationProgress);
    if (frameTime >= animationTime) {
      callback(lastStep);
      doneCallback();
      _this.animate = null;
    } else {
      callback(step);
      requestAnimationFrame(_this.animate);
    }
  };
  requestAnimationFrame(this.animate);
}

function animatePaddingFunction(_ref2) {
  var _this2 = this;

  var animationTime = _ref2.animationTime,
      callback = _ref2.callback,
      cancelCallback = _ref2.cancelCallback,
      doneCallback = _ref2.doneCallback,
      _ref2$animationName = _ref2.animationName,
      animationName = _ref2$animationName === undefined ? "easeOut" : _ref2$animationName;

  var lastStep = 1;
  if (this.zoomPaddingAnimation) {
    cancelAnimationFrame(this.zoomPaddingAnimation);
    cancelCallback();
  }
  var startTime = new Date().getTime();

  // if animation has only one step
  if (animationTime === 1) {
    callback(lastStep);
    doneCallback();
    this.zoomPaddingAnimation = null;
    return;
  }
  this.zoomPaddingAnimation = function () {
    if (!_this2.zoomPaddingAnimation) return;

    var frameTime = new Date().getTime() - startTime;
    var animationProgress = frameTime / animationTime;
    var animationType = {
      easeOut: easeOut,
      easeIn: easeIn,
      linear: linear
    }[animationName];
    var step = animationType(animationProgress);
    if (frameTime >= animationTime) {
      callback(lastStep);
      doneCallback();
      _this2.zoomPaddingAnimation = null;
    } else {
      callback(step);
      requestAnimationFrame(_this2.zoomPaddingAnimation);
    }
  };
  requestAnimationFrame(this.zoomPaddingAnimation);
}

function checkZoomBounds(zoom, minScale, maxScale, scaleAnimationPadding) {
  var maxScaleWithPadding = maxScale + scaleAnimationPadding;
  var minScaleWithPadding = minScale - scaleAnimationPadding;

  if (!isNaN(maxScale) && zoom >= maxScaleWithPadding) return maxScaleWithPadding;
  if (!isNaN(minScale) && zoom <= minScaleWithPadding) return minScaleWithPadding;
  return zoom;
}

function checkPositionBounds(positionX, positionY, bounds, limitToBounds) {
  var minPositionX = bounds.minPositionX,
      minPositionY = bounds.minPositionY,
      maxPositionX = bounds.maxPositionX,
      maxPositionY = bounds.maxPositionY;

  var x = boundLimiter(positionX, minPositionX, maxPositionX, limitToBounds);
  var y = boundLimiter(positionY, minPositionY, maxPositionY, limitToBounds);
  return { x: x, y: y };
}

function getDelta(event, customDelta) {
  var deltaY = event ? event.deltaY < 0 ? 1 : -1 : 0;
  var delta = checkIsNumber(customDelta, deltaY);
  return delta;
}

function wheelMousePosition(event, contentComponent, scale) {
  var contentRect = contentComponent.getBoundingClientRect();

  // mouse position x, y over wrapper component
  var mouseX = (event.clientX - contentRect.left) / scale;
  var mouseY = (event.clientY - contentRect.top) / scale;

  if (isNaN(mouseX) || isNaN(mouseY)) return console.warn("No mouse or touch offset found");

  return {
    mouseX: mouseX,
    mouseY: mouseY
  };
}

function getComponentsSizes(wrapperComponent, newScale) {
  var wrapperRect = wrapperComponent.getBoundingClientRect();

  var wrapperWidth = wrapperRect.width;
  var wrapperHeight = wrapperRect.height;

  var newContentWidth = wrapperWidth * newScale;
  var newContentHeight = wrapperHeight * newScale;
  var newDiffWidth = wrapperWidth - newContentWidth;
  var newDiffHeight = wrapperHeight - newContentHeight;

  return {
    wrapperWidth: wrapperWidth,
    wrapperHeight: wrapperHeight,
    newContentWidth: newContentWidth,
    newDiffWidth: newDiffWidth,
    newContentHeight: newContentHeight,
    newDiffHeight: newDiffHeight
  };
}

function calculateZoom(zoomStep, delta, customScale, disabledPadding) {
  var _stateProvider = this.stateProvider,
      scale = _stateProvider.scale,
      maxScale = _stateProvider.maxScale,
      minScale = _stateProvider.minScale,
      scaleAnimationPadding = _stateProvider.scaleAnimationPadding;

  var padding = disabledPadding ? 0 : scaleAnimationPadding;
  if (typeof customScale === "number" && customScale === scale) return scale;
  if (typeof customScale === "number") return checkZoomBounds(customScale, minScale, maxScale, padding);

  var newScale = scale + zoomStep * delta * (scale / 100);

  var calculatedScale = checkZoomBounds(roundNumber(newScale, 2), minScale, maxScale, padding);
  if (scale === calculatedScale) return scale;

  return calculatedScale;
}

function calculateTransformation(mouseX, mouseY, scaleDifference, bounds) {
  if (typeof mouseX !== "number" || typeof mouseY !== "number") return console.error("Mouse X and Y position were not provided!");
  var _stateProvider2 = this.stateProvider,
      positionX = _stateProvider2.positionX,
      positionY = _stateProvider2.positionY,
      limitToBounds = _stateProvider2.limitToBounds,
      transformEnabled = _stateProvider2.transformEnabled;


  if (!transformEnabled) return { newPositionX: positionX, newPositionY: positionY };

  var calculatedPositionX = positionX - mouseX * scaleDifference;
  var calculatedPositionY = positionY - mouseY * scaleDifference;

  var _checkPositionBounds = checkPositionBounds(calculatedPositionX, calculatedPositionY, bounds, limitToBounds),
      x = _checkPositionBounds.x,
      y = _checkPositionBounds.y;

  return { newPositionX: x, newPositionY: y };
}

function handleZoom(event, customMousePosition, customDelta, customStep, animationTime, disabledPadding) {
  var _this = this;

  var _stateProvider3 = this.stateProvider,
      isDown = _stateProvider3.isDown,
      zoomingEnabled = _stateProvider3.zoomingEnabled,
      disabled = _stateProvider3.disabled,
      scale = _stateProvider3.scale,
      limitToWrapperBounds = _stateProvider3.limitToWrapperBounds,
      wheelStep = _stateProvider3.wheelStep,
      positionY = _stateProvider3.positionY,
      positionX = _stateProvider3.positionX;
  var _state = this.state,
      wrapperComponent = _state.wrapperComponent,
      contentComponent = _state.contentComponent;


  if (isDown || !zoomingEnabled || disabled) return;
  if (disabledPadding && this.zoomPaddingTimer) {
    clearTimeout(this.zoomPaddingTimer);
    this.zoomPaddingTimer = null;
  }
  event.preventDefault();
  event.stopPropagation();
  // Scale transformation
  var delta = getDelta(event, customDelta);
  var targetScale = calculateZoom.bind(this, customStep || wheelStep, delta, null, disabledPadding)();

  if (targetScale === scale) return;

  // Get new element sizes to calculate bounds

  var _getComponentsSizes = getComponentsSizes(wrapperComponent, targetScale),
      wrapperWidth = _getComponentsSizes.wrapperWidth,
      wrapperHeight = _getComponentsSizes.wrapperHeight,
      newContentWidth = _getComponentsSizes.newContentWidth,
      newDiffWidth = _getComponentsSizes.newDiffWidth,
      newContentHeight = _getComponentsSizes.newContentHeight,
      newDiffHeight = _getComponentsSizes.newDiffHeight;

  // Position transformation


  var _ref = customMousePosition || wheelMousePosition(event, contentComponent, scale),
      mouseX = _ref.mouseX,
      mouseY = _ref.mouseY;

  var scaleDifference = targetScale - scale;

  var bounds = calculateBoundingArea(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, limitToWrapperBounds);

  // Save last zoom bounds, to speed up panning function
  this.bounds = bounds;
  this.lastDelta = delta;

  // Calculate transformations

  var _calculateTransformat = calculateTransformation.bind(this, mouseX, mouseY, scaleDifference, bounds)(),
      newPositionX = _calculateTransformat.newPositionX,
      newPositionY = _calculateTransformat.newPositionY;

  var speed = checkIsNumber(animationTime, 1);
  if (!animationTime || Math.abs(scaleDifference) < 0.05) {
    this.stateProvider = _extends({}, this.stateProvider, {
      positionX: newPositionX,
      positionY: newPositionY,
      scale: targetScale,
      previousScale: scale
    });
    // update component transformation
    this.setContentComponentTransformation();
  } else {
    // animate
    var params = {
      animationVariable: disabledPadding ? this.zoomPaddingAnimation : this.animate,
      animationTime: speed,
      animationName: "linear",
      callback: function callback(step) {
        var newPosX = positionX + (newPositionX - positionX) * step;
        var newPosY = positionY + (newPositionY - positionY) * step;
        var newScale = scale + (targetScale - scale) * step;
        _this.stateProvider = _extends({}, _this.stateProvider, {
          positionX: newPosX,
          positionY: newPosY,
          scale: newScale,
          previousScale: scale
        });
        // update component transformation
        _this.setContentComponentTransformation();
      },
      doneCallback: function doneCallback() {
        if (animationTime !== "wheel") {
          handleCallback(_this.props.onZoomChange, _this.getCallbackProps());
        }
      },
      cancelCallback: function cancelCallback() {
        if (animationTime !== "wheel") {
          handleCallback(_this.props.onZoomChange, _this.getCallbackProps());
        }
      }
    };
    if (disabledPadding) {
      animatePaddingFunction.bind(this, params)();
    } else {
      animateFunction.bind(this, params)();
    }
  }
}

function handleZoomControls(event, customDelta, customStep) {
  var _stateProvider4 = this.stateProvider,
      positionX = _stateProvider4.positionX,
      positionY = _stateProvider4.positionY,
      scale = _stateProvider4.scale,
      zoomInAnimationSpeed = _stateProvider4.zoomInAnimationSpeed,
      zoomOutAnimationSpeed = _stateProvider4.zoomOutAnimationSpeed;
  var wrapperComponent = this.state.wrapperComponent;

  // calculate zoom center

  var wrapperWidth = wrapperComponent.offsetWidth;
  var wrapperHeight = wrapperComponent.offsetHeight;
  var mouseX = (Math.abs(positionX) + wrapperWidth / 2) / scale;
  var mouseY = (Math.abs(positionY) + wrapperHeight / 2) / scale;
  var animationSpeed = customDelta ? zoomInAnimationSpeed : zoomOutAnimationSpeed;
  handleZoom.bind(this, event, { mouseX: mouseX, mouseY: mouseY }, customDelta, customStep, animationSpeed)();
}

function handleZoomDbClick(event) {
  var _stateProvider5 = this.stateProvider,
      dbClickMode = _stateProvider5.dbClickMode,
      dbClickStep = _stateProvider5.dbClickStep,
      dbClickAnimationSpeed = _stateProvider5.dbClickAnimationSpeed;


  if (dbClickMode === "reset") {
    return resetTransformations.bind(this, event, dbClickAnimationSpeed)();
  }
  var delta = dbClickMode === "zoomOut" ? -1 : 1;
  handleZoom.bind(this, event, null, delta, dbClickStep, dbClickAnimationSpeed)();
}

function resetTransformations() {
  var _this2 = this;

  var _props$defaultValues = this.props.defaultValues,
      defaultScale = _props$defaultValues.defaultScale,
      defaultPositionX = _props$defaultValues.defaultPositionX,
      defaultPositionY = _props$defaultValues.defaultPositionY;
  var _stateProvider6 = this.stateProvider,
      scale = _stateProvider6.scale,
      positionX = _stateProvider6.positionX,
      positionY = _stateProvider6.positionY,
      disabled = _stateProvider6.disabled,
      resetAnimationSpeed = _stateProvider6.resetAnimationSpeed;

  if (disabled) return;
  if (scale === defaultScale && positionX === defaultPositionX && positionY === defaultPositionY) return;

  var targetScale = checkIsNumber(defaultScale, initialState.scale);
  var newPositionX = checkIsNumber(defaultPositionX, initialState.positionX);
  var newPositionY = checkIsNumber(defaultPositionY, initialState.positionY);

  // animate
  animateFunction.bind(this, {
    animationVariable: this.animate,
    animationTime: resetAnimationSpeed,
    animationName: "linear",
    callback: function callback(step) {
      var newPosX = positionX + (newPositionX - positionX) * step;
      var newPosY = positionY + (newPositionY - positionY) * step;
      var newScale = scale + (targetScale - scale) * step;
      _this2.stateProvider = _extends({}, _this2.stateProvider, {
        scale: newScale,
        positionX: newPosX,
        positionY: newPosY,
        previousScale: _this2.stateProvider.scale
      });
      // update component transformation
      _this2.setContentComponentTransformation();
    },
    doneCallback: function doneCallback() {
      handleCallback(_this2.props.onZoomChange, _this2.getCallbackProps());
    },
    cancelCallback: function cancelCallback() {
      handleCallback(_this2.props.onZoomChange, _this2.getCallbackProps());
    }
  })();
}

function animatePadding(event) {
  var _stateProvider7 = this.stateProvider,
      positionX = _stateProvider7.positionX,
      positionY = _stateProvider7.positionY,
      scale = _stateProvider7.scale,
      scalePaddingAnimationSpeed = _stateProvider7.scalePaddingAnimationSpeed,
      minScale = _stateProvider7.minScale,
      maxScale = _stateProvider7.maxScale;

  if (scale > minScale && scale < maxScale) return;
  var wrapperComponent = this.state.wrapperComponent;

  // calculate zoom center

  var wrapperWidth = wrapperComponent.offsetWidth;
  var wrapperHeight = wrapperComponent.offsetHeight;
  var mouseX = (Math.abs(positionX) + wrapperWidth / 2) / scale;
  var mouseY = (Math.abs(positionY) + wrapperHeight / 2) / scale;
  handleZoom.bind(this, event, { mouseX: mouseX, mouseY: mouseY }, this.lastDelta, 1, scalePaddingAnimationSpeed, true)();
}

function round(number, decimal) {
  var roundNumber$$1 = Math.pow(10, decimal);
  return Math.round(number * roundNumber$$1) / roundNumber$$1;
}

function getCurrentDistance(event) {
  return getDistance(event.touches[0], event.touches[1]);
}

function checkIfInfinite(number) {
  return number === Infinity || number === -Infinity;
}

function calculatePinchZoom(currentDistance, pinchStartDistance) {
  var _stateProvider = this.stateProvider,
      minScale = _stateProvider.minScale,
      maxScale = _stateProvider.maxScale,
      scaleAnimationPadding = _stateProvider.scaleAnimationPadding;

  if (typeof pinchStartDistance !== "number" || typeof currentDistance !== "number") return console.error("Pinch touches distance was not provided");

  if (currentDistance < 0) return;
  var touchProportion = currentDistance / pinchStartDistance;
  var scaleDifference = touchProportion * this.pinchStartScale;

  return checkZoomBounds(scaleDifference, minScale, maxScale, scaleAnimationPadding);
}

function calculateMidpoint(event, scale, contentComponent) {
  var contentRect = contentComponent.getBoundingClientRect();
  var touches = event.touches;

  var firstPointX = round(touches[0].clientX - contentRect.left, 5);
  var firstPointY = round(touches[0].clientY - contentRect.top, 5);
  var secondPointX = round(touches[1].clientX - contentRect.left, 5);
  var secondPointY = round(touches[1].clientY - contentRect.top, 5);

  return {
    mouseX: (firstPointX + secondPointX) / 2 / scale,
    mouseY: (firstPointY + secondPointY) / 2 / scale
  };
}

function handleZoomPinch(event) {
  var _stateProvider2 = this.stateProvider,
      isDown = _stateProvider2.isDown,
      zoomingEnabled = _stateProvider2.zoomingEnabled,
      disabled = _stateProvider2.disabled,
      scale = _stateProvider2.scale,
      limitToWrapperBounds = _stateProvider2.limitToWrapperBounds;
  var _state = this.state,
      wrapperComponent = _state.wrapperComponent,
      contentComponent = _state.contentComponent;

  if (isDown || !zoomingEnabled || disabled) return;

  if (event.cancelable) {
    event.preventDefault();
    event.stopPropagation();
  }

  // if one finger starts from outside of wrapper
  if (this.pinchStartDistance === null) return;

  // Position transformation

  var _calculateMidpoint = calculateMidpoint(event, scale, contentComponent),
      mouseX = _calculateMidpoint.mouseX,
      mouseY = _calculateMidpoint.mouseY;

  // if touches goes off of the wrapper element


  if (checkIfInfinite(mouseX) || checkIfInfinite(mouseY)) return;

  var currentDistance = getCurrentDistance(event);

  var newScale = calculatePinchZoom.bind(this, currentDistance, this.pinchStartDistance)();
  if (checkIfInfinite(newScale) || newScale === scale) return;

  var scaleDifference = newScale - scale;

  // Get new element sizes to calculate bounds

  var _getComponentsSizes = getComponentsSizes(wrapperComponent, newScale),
      wrapperWidth = _getComponentsSizes.wrapperWidth,
      wrapperHeight = _getComponentsSizes.wrapperHeight,
      newContentWidth = _getComponentsSizes.newContentWidth,
      newDiffWidth = _getComponentsSizes.newDiffWidth,
      newContentHeight = _getComponentsSizes.newContentHeight,
      newDiffHeight = _getComponentsSizes.newDiffHeight;

  var bounds = calculateBoundingArea(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, limitToWrapperBounds);

  // Save last zoom bounds, to speed up panning function
  this.bounds = bounds;

  // Calculate transformations

  var _calculateTransformat = calculateTransformation.bind(this, mouseX, mouseY, scaleDifference, bounds)(),
      newPositionX = _calculateTransformat.newPositionX,
      newPositionY = _calculateTransformat.newPositionY;

  this.lastDistance = currentDistance;

  this.stateProvider = _extends({}, this.stateProvider, {
    positionX: newPositionX,
    positionY: newPositionY,
    scale: newScale,
    previousScale: scale
  });
  // update component transformation
  this.setContentComponentTransformation();
}

function getSizes(wrapperComponent, contentComponent) {
  var wrapperRect = wrapperComponent.getBoundingClientRect();
  var contentRect = contentComponent.getBoundingClientRect();

  var wrapperWidth = wrapperRect.width;
  var wrapperHeight = wrapperRect.height;
  var contentWidth = contentRect.width;
  var contentHeight = contentRect.height;
  var diffWidth = wrapperWidth - contentWidth;
  var diffHeight = wrapperHeight - contentHeight;

  return {
    wrapperWidth: wrapperWidth,
    wrapperHeight: wrapperHeight,
    contentWidth: contentWidth,
    diffWidth: diffWidth,
    contentHeight: contentHeight,
    diffHeight: diffHeight
  };
}

function handleCalculateBounds(wrapperComponent, contentComponent, limitToWrapperBounds) {
  var _getSizes = getSizes(wrapperComponent, contentComponent),
      wrapperWidth = _getSizes.wrapperWidth,
      contentWidth = _getSizes.contentWidth,
      diffWidth = _getSizes.diffWidth,
      wrapperHeight = _getSizes.wrapperHeight,
      contentHeight = _getSizes.contentHeight,
      diffHeight = _getSizes.diffHeight;

  return calculateBoundingArea(wrapperWidth, contentWidth, diffWidth, wrapperHeight, contentHeight, diffHeight, limitToWrapperBounds);
}

function getClientPosition(event) {
  var touches = event.touches;

  // Mobile points

  if (touches && touches.length === 1) {
    return { clientX: touches[0].clientX, clientY: touches[0].clientY };
  }
  // Desktop points
  if (!touches) {
    return { clientX: event.clientX, clientY: event.clientY };
  }
  return null;
}

function handlePanning(event) {
  var _stateProvider = this.stateProvider,
      limitToWrapperBounds = _stateProvider.limitToWrapperBounds,
      limitToBounds = _stateProvider.limitToBounds,
      positionX = _stateProvider.positionX,
      positionY = _stateProvider.positionY,
      lockAxisX = _stateProvider.lockAxisX,
      lockAxisY = _stateProvider.lockAxisY;
  var _state = this.state,
      wrapperComponent = _state.wrapperComponent,
      contentComponent = _state.contentComponent;


  if (!this.startCoords) return;
  var _startCoords = this.startCoords,
      x = _startCoords.x,
      y = _startCoords.y;


  var positions = getClientPosition(event);
  if (!positions) return console.error("Cannot find mouse client positions");
  var clientX = positions.clientX,
      clientY = positions.clientY;

  // Calculate bounding area

  var bounds = this.bounds;

  // If panning is fired before scaling and there are no bounds calculated
  if (!bounds) {
    var calculatedBounds = handleCalculateBounds(wrapperComponent, contentComponent, limitToWrapperBounds);
    this.bounds = calculatedBounds;
    bounds = calculatedBounds;
  }

  // Get Position
  var newPositionX = lockAxisX ? positionX : clientX - x;
  var newPositionY = lockAxisY ? positionY : clientY - y;

  // If position didn't change
  if (newPositionX === positionX && newPositionY === positionY) return;
  var calculatedPosition = checkPositionBounds(newPositionX, newPositionY, bounds, limitToBounds);

  // Save panned position
  this.stateProvider = _extends({}, this.stateProvider, {
    positionX: calculatedPosition.x,
    positionY: calculatedPosition.y
  });
  // update component transformation
  this.setContentComponentTransformation();
}

function velocityTimeSpeed(speed, animationTime) {
  var velocityTimeBasedOnMove = this.stateProvider.velocityTimeBasedOnMove;


  if (velocityTimeBasedOnMove) {
    return animationTime - animationTime / Math.max(1.6, speed);
  }
  return animationTime;
}

function handleEnableVelocity() {
  this.setState({ startAnimation: false });
}

function handleFireVelocity() {
  this.setState({ startAnimation: true });
}

function animateVelocity() {
  var _this = this;

  var _stateProvider = this.stateProvider,
      positionX = _stateProvider.positionX,
      positionY = _stateProvider.positionY,
      limitToBounds = _stateProvider.limitToBounds,
      velocityAnimationSpeed = _stateProvider.velocityAnimationSpeed,
      lockAxisX = _stateProvider.lockAxisX,
      lockAxisY = _stateProvider.lockAxisY;

  if (!this.velocity || !this.bounds) return handleDisableAnimation.bind(this)();
  var _velocity = this.velocity,
      velocityX = _velocity.velocityX,
      velocityY = _velocity.velocityY,
      velocity = _velocity.velocity;

  var animationTime = velocityTimeSpeed.bind(this, velocity, velocityAnimationSpeed)();
  var targetX = velocityX;
  var targetY = velocityY;

  this.offsetX = positionX;
  this.offsetY = positionY;

  animateFunction.bind(this, {
    animationVariable: this.animate,
    animationTime: animationTime,
    callback: function callback(step) {
      var currentPositionX = lockAxisX ? positionX : _this.offsetX + targetX - targetX * step;
      var currentPositionY = lockAxisY ? positionY : _this.offsetY + targetY - targetY * step;

      var calculatedPosition = checkPositionBounds(currentPositionX, currentPositionY, _this.bounds, limitToBounds);

      _this.offsetX = calculatedPosition.x;
      _this.offsetY = calculatedPosition.y;

      // Save panned position
      _this.stateProvider = _extends({}, _this.stateProvider, {
        positionX: calculatedPosition.x,
        positionY: calculatedPosition.y
      });
      // update component transformation
      _this.setContentComponentTransformation();
    },
    doneCallback: function doneCallback() {
      return handleDisableAnimation.bind(_this)();
    },
    cancelCallback: function cancelCallback() {
      return _this.velocity = null;
    }
  })();
}

function calculateVelocityStart(event) {
  var _this2 = this;

  var _stateProvider2 = this.stateProvider,
      enableVelocity = _stateProvider2.enableVelocity,
      minVelocityScale = _stateProvider2.minVelocityScale,
      scale = _stateProvider2.scale,
      disabled = _stateProvider2.disabled,
      velocitySensitivity = _stateProvider2.velocitySensitivity;

  if (!enableVelocity || minVelocityScale >= scale || disabled) return;
  handleEnableVelocity.bind(this)();
  var now = Date.now();
  if (this.lastMousePosition) {
    var _position = getClientPosition(event);
    if (!_position) return console.error("No mouse or touch position detected");
    var clientX = _position.clientX,
        clientY = _position.clientY;

    var distanceX = (clientX - this.lastMousePosition.clientX) * scale;
    var distanceY = (clientY - this.lastMousePosition.clientY) * scale;
    var interval = now - this.velocityTime;
    var velocityX = distanceX / interval * velocitySensitivity;
    var velocityY = distanceY / interval * velocitySensitivity;
    var velocity = Math.sqrt(distanceX * distanceX + distanceY * distanceY) / interval * velocitySensitivity;

    if (this.velocity && velocity < this.velocity.velocity && this.throttle) return;
    this.velocity = { velocityX: velocityX, velocityY: velocityY, velocity: velocity };

    // throttling
    if (this.throttle) clearTimeout(this.throttle);
    this.throttle = setTimeout(function () {
      return _this2.throttle = false;
    }, this.throttleTime);
  }
  var position = getClientPosition(event);
  this.lastMousePosition = position;
  this.velocityTime = now;
}

// We want to make event listeners non-passive, and to do so have to check

function makePassiveEventOption(passive) {
  return passive;
}

var Context = React__default.createContext({});

var timer = null;
var timerTime = 100;
var wheelTimer = null;
var wheelTime = 50;

var StateProvider = function (_Component) {
  inherits(StateProvider, _Component);

  function StateProvider() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, StateProvider);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StateProvider.__proto__ || Object.getPrototypeOf(StateProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      wrapperComponent: null,
      contentComponent: null,
      startAnimation: false
    }, _this.stateProvider = _extends({}, initialState, _this.props.dynamicValues, _this.props.defaultValues, {
      previousScale: _this.props.defaultValues.scale || initialState.scale
    }), _this.pinchStartDistance = null, _this.lastDistance = null, _this.pinchStartScale = null, _this.distance = null, _this.bounds = null, _this.startPanningCoords = null, _this.velocityTime = null, _this.lastMousePosition = null, _this.velocity = null, _this.animate = false, _this.offsetX = null, _this.offsetY = null, _this.throttle = false, _this.throttleTime = 30, _this.zoomPaddingAnimation = null, _this.zoomPaddingTimer = null, _this.wheelEnd = false, _this.lastWheelScale = null, _this.lastWheelDelta = null, _this.handleWheel = function (event) {
      var _this$stateProvider = _this.stateProvider,
          enableWheel = _this$stateProvider.enableWheel,
          enableTouchPadPinch = _this$stateProvider.enableTouchPadPinch,
          scale = _this$stateProvider.scale,
          maxScale = _this$stateProvider.maxScale,
          minScale = _this$stateProvider.minScale;
      var _this$props = _this.props,
          onWheelStart = _this$props.onWheelStart,
          onWheel = _this$props.onWheel,
          onWheelStop = _this$props.onWheelStop,
          onZoomChange = _this$props.onZoomChange;

      // ctrlKey detects if touchpad execute wheel or pinch gesture

      if (!enableWheel && !event.ctrlKey) return;
      if (!enableTouchPadPinch && event.ctrlKey) return;

      if (scale != _this.lastWheelScale) {
        _this.wheelStart = false;
        _this.lastWheelScale = scale;
        clearTimeout(timer);
        timer = setTimeout(function () {
          animatePadding.bind(_this, event)();
          handleCallback(onWheelStop, _this.getCallbackProps());
          handleCallback(onZoomChange, _this.getCallbackProps());
          timer = null;
          _this.lastWheelScale = null;
          _this.wheelEnd = true;
        }, timerTime);
      }
      if (!_this.lastWheelDelta) _this.lastWheelDelta = event.deltaY;
      if (_this.wheelEnd) {
        if (Math.abs(event.deltaY) <= Math.abs(_this.lastWheelDelta)) {
          clearTimeout(wheelTimer);
          wheelTimer = setTimeout(function () {
            wheelTimer = null;
            _this.wheelEnd = false;
            _this.lastWheelDelta = null;
          }, wheelTime);
          _this.lastWheelDelta = event.deltaY;
        }
        event.stopPropagation();
        event.preventDefault();
        return;
      }

      if (!timer) {
        // Wheel start event
        handleDisableAnimation.bind(_this)();
        handleCallback(onWheelStart, _this.getCallbackProps());
      }

      // Wheel event
      handleZoom.bind(_this, event, undefined, undefined, undefined, "wheel")();
      handleCallback(onWheel, _this.getCallbackProps());

      // Wheel stop event
      if (scale > maxScale || scale < minScale) {
        clearTimeout(_this.zoomPaddingTimer);
        _this.zoomPaddingTimer = setTimeout(function () {}, 10);
      }
    }, _this.checkIsPanningActive = function (event) {
      var _this$stateProvider2 = _this.stateProvider,
          panningEnabled = _this$stateProvider2.panningEnabled,
          disabled = _this$stateProvider2.disabled;


      return !_this.isDown || !panningEnabled || disabled || event.touches && (event.touches.length !== 1 || Math.abs(_this.startCoords.x - event.touches[0].clientX) < 1);
    }, _this.handleSetUpPanning = function (x, y) {
      var _this$stateProvider3 = _this.stateProvider,
          positionX = _this$stateProvider3.positionX,
          positionY = _this$stateProvider3.positionY;

      _this.isDown = true;
      _this.startCoords = { x: x - positionX, y: y - positionY };

      handleCallback(_this.props.onPanningStart, _this.getCallbackProps());
    }, _this.handleStartPanning = function (event) {
      var _this$stateProvider4 = _this.stateProvider,
          panningEnabled = _this$stateProvider4.panningEnabled,
          disabled = _this$stateProvider4.disabled,
          wrapperComponent = _this$stateProvider4.wrapperComponent;
      var target = event.target,
          touches = event.touches;

      if (!panningEnabled || disabled || wrapperComponent && !wrapperComponent.contains(target)) return;

      handleDisableAnimation.bind(_this)();
      // Mobile points
      if (touches && touches.length === 1) {
        _this.handleSetUpPanning(touches[0].clientX, touches[0].clientY);
      }
      // Desktop points
      if (!touches) {
        _this.handleSetUpPanning(event.clientX, event.clientY);
      }
    }, _this.handlePanning = function (event) {
      event.preventDefault();
      if (_this.checkIsPanningActive(event)) return;
      event.stopPropagation();

      calculateVelocityStart.bind(_this, event)();
      handlePanning.bind(_this, event)();
      handleCallback(_this.props.onPanning, _this.getCallbackProps());
    }, _this.handleStopPanning = function () {
      if (_this.isDown) {
        _this.isDown = false;
        handleFireVelocity.bind(_this)();
        handleCallback(_this.props.onPanningStop, _this.getCallbackProps());
      }
    }, _this.handlePinchStart = function (event) {
      var scale = _this.stateProvider.scale;

      event.preventDefault();
      event.stopPropagation();

      handleDisableAnimation.bind(_this)();
      var distance = getDistance(event.touches[0], event.touches[1]);
      _this.pinchStartDistance = distance;
      _this.lastDistance = distance;
      _this.pinchStartScale = scale;

      handleCallback(_this.props.onPinchingStart, _this.getCallbackProps());
    }, _this.handlePinch = function (event) {
      handleZoomPinch.bind(_this, event)();
      handleCallback(_this.props.onPinching, _this.getCallbackProps());
    }, _this.handlePinchStop = function (event) {
      if (typeof _this.pinchStartScale === "number") {
        _this.pinchStartDistance = null;
        _this.lastDistance = null;
        _this.pinchStartScale = null;
        animatePadding.bind(_this, event)();
        handleCallback(_this.props.onPinchingStop, _this.getCallbackProps());
      }
    }, _this.handleTouchStart = function (event) {
      var disabled = _this.stateProvider.disabled;
      var touches = event.touches;

      handleDisableAnimation.bind(_this)();
      if (disabled) return;
      if (touches && touches.length === 1) return _this.handleStartPanning(event);
      if (touches && touches.length === 2) return _this.handlePinchStart(event);
    }, _this.handleTouch = function (event) {
      var _this$stateProvider5 = _this.stateProvider,
          panningEnabled = _this$stateProvider5.panningEnabled,
          pinchEnabled = _this$stateProvider5.pinchEnabled,
          disabled = _this$stateProvider5.disabled;

      if (disabled) return;
      if (panningEnabled && event.touches.length === 1) return _this.handlePanning(event);
      if (pinchEnabled && event.touches.length === 2) return _this.handlePinch(event);
    }, _this.handleTouchStop = function (event) {
      _this.handlePinchStop(event);
      _this.handleStopPanning();
    }, _this.resetLastMousePosition = function () {
      return _this.stateProvider = _extends({}, _this.stateProvider, { lastMouseEventPosition: null });
    }, _this.zoomIn = function (event) {
      var _this$stateProvider6 = _this.stateProvider,
          zoomingEnabled = _this$stateProvider6.zoomingEnabled,
          disabled = _this$stateProvider6.disabled,
          zoomInStep = _this$stateProvider6.zoomInStep;

      if (!event) throw Error("Zoom in function require event prop");
      if (!zoomingEnabled || disabled) return;
      handleZoomControls.bind(_this, event, 1, zoomInStep)();
    }, _this.zoomOut = function (event) {
      var _this$stateProvider7 = _this.stateProvider,
          zoomingEnabled = _this$stateProvider7.zoomingEnabled,
          disabled = _this$stateProvider7.disabled,
          zoomOutStep = _this$stateProvider7.zoomOutStep;

      if (!event) throw Error("Zoom out function require event prop");
      if (!zoomingEnabled || disabled) return;
      handleZoomControls.bind(_this, event, -1, zoomOutStep)();
    }, _this.handleDbClick = function (event) {
      var _this$stateProvider8 = _this.stateProvider,
          zoomingEnabled = _this$stateProvider8.zoomingEnabled,
          disabled = _this$stateProvider8.disabled,
          dbClickStep = _this$stateProvider8.dbClickStep,
          dbClickEnabled = _this$stateProvider8.dbClickEnabled;

      if (!event) throw Error("Double click function require event prop");
      if (!zoomingEnabled || disabled || !dbClickEnabled) return;
      handleZoomDbClick.bind(_this, event, 1, dbClickStep)();
    }, _this.setScale = function (scale) {
      _this.stateProvider = _extends({}, _this.stateProvider, { scale: scale });
      // update component transformation
      _this.setContentComponentTransformation();
    }, _this.setPositionX = function (positionX) {
      _this.stateProvider = _extends({}, _this.stateProvider, { positionX: roundNumber(positionX, 3) });
      // update component transformation
      _this.setContentComponentTransformation();
    }, _this.setPositionY = function (positionY) {
      _this.stateProvider = _extends({}, _this.stateProvider, { positionY: roundNumber(positionY, 3) });
      // update component transformation
      _this.setContentComponentTransformation();
    }, _this.setTransform = function (positionX, positionY, scale) {
      if (!_this.stateProvider.transformEnabled) return;
      !isNaN(scale) && _this.setScale(scale);
      !isNaN(positionX) && _this.setPositionX(positionX);
      !isNaN(positionY) && _this.setPositionY(positionY);
    }, _this.resetTransform = function () {
      var disabled = _this.stateProvider.disabled;

      if (disabled) return;
      resetTransformations.bind(_this)();
    }, _this.setWrapperComponent = function (wrapperComponent) {
      _this.setState({ wrapperComponent: wrapperComponent });
    }, _this.setContentComponent = function (contentComponent) {
      _this.setState({ contentComponent: contentComponent }, function () {
        if (_this.stateProvider.isCentered) {
          var scale = _this.stateProvider.scale;

          var rect = _this.state.wrapperComponent.getBoundingClientRect();
          _this.stateProvider.positionX = (rect.width - rect.width * scale) / 2;
          _this.stateProvider.positionY = (rect.height - rect.height * scale) / 2;
        }
        _this.setContentComponentTransformation();
      });
    }, _this.setContentComponentTransformation = function () {
      var contentComponent = _this.state.contentComponent;

      if (!contentComponent) return console.error("There is no content component");
      var transform = "translate(" + _this.stateProvider.positionX + "px, " + _this.stateProvider.positionY + "px) scale(" + _this.stateProvider.scale + ")";
      contentComponent.style.transform = transform;
      _this.setState({ updated: true });
    }, _this.getCallbackProps = function () {
      return {
        positionX: _this.stateProvider.positionX,
        positionY: _this.stateProvider.positionY,
        scale: _this.stateProvider.scale,
        sensitivity: _this.stateProvider.sensitivity,
        maxScale: _this.stateProvider.maxScale,
        minScale: _this.stateProvider.minScale,
        wheelAnimationSpeed: _this.stateProvider.wheelAnimationSpeed,
        zoomAnimationSpeed: _this.stateProvider.zoomAnimationSpeed,
        pinchAnimationSpeed: _this.stateProvider.pinchAnimationSpeed,
        panAnimationSpeed: _this.stateProvider.panAnimationSpeed,
        minPositionX: _this.stateProvider.minPositionX,
        minPositionY: _this.stateProvider.minPositionY,
        maxPositionX: _this.stateProvider.maxPositionX,
        maxPositionY: _this.stateProvider.maxPositionY,
        limitToBounds: _this.stateProvider.limitToBounds,
        zoomingEnabled: _this.stateProvider.zoomingEnabled,
        panningEnabled: _this.stateProvider.panningEnabled,
        transformEnabled: _this.stateProvider.transformEnabled,
        pinchEnabled: _this.stateProvider.pinchEnabled,
        limitToWrapperBounds: _this.stateProvider.limitToWrapperBounds,
        disabled: _this.stateProvider.disabled,
        zoomOutStep: _this.stateProvider.zoomOutStep,
        zoomInStep: _this.stateProvider.zoomInStep,
        dbClickStep: _this.stateProvider.dbClickStep,
        pinchSensitivity: _this.stateProvider.pinchSensitivity,
        dbClickEnabled: _this.stateProvider.dbClickEnabled,
        lastPositionZoomEnabled: _this.stateProvider.lastPositionZoomEnabled,
        previousScale: _this.stateProvider.previousScale,
        scaleAnimationPadding: _this.stateProvider.scalePadding,
        lockAxisX: _this.stateProvider.lockAxisX,
        lockAxisY: _this.stateProvider.lockAxisY,
        velocityTimeBasedOnMove: _this.stateProvider.velocityTimeBasedOnMove,
        velocitySensitivity: _this.stateProvider.velocitySensitivity,
        scalePaddingAnimationSpeed: _this.stateProvider.scalePaddingAnimationSpeed,
        enableWheel: _this.stateProvider.enableWheel,
        enableTouchPadPinch: _this.stateProvider.enableTouchPadPinch
      };
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  // pinch helpers

  // velocity helpers

  // zoom helpers

  // wheel helpers


  createClass(StateProvider, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var passiveOption = makePassiveEventOption(false);

      // Panning on window to allow panning when mouse is out of wrapper
      window.addEventListener("mousedown", this.handleStartPanning, passiveOption);
      window.addEventListener("mousemove", this.handlePanning, passiveOption);
      window.addEventListener("mouseup", this.handleStopPanning, passiveOption);
      return function () {
        window.removeEventListener("mousedown", _this2.handleStartPanning, passiveOption);
        window.removeEventListener("mousemove", _this2.handlePanning, passiveOption);
        window.removeEventListener("mouseup", _this2.handleStopPanning, passiveOption);
      };
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(oldProps, oldState) {
      var _state = this.state,
          wrapperComponent = _state.wrapperComponent,
          contentComponent = _state.contentComponent,
          startAnimation = _state.startAnimation;
      var dynamicValues = this.props.dynamicValues;

      if (!oldState.contentComponent && contentComponent) {
        this.stateProvider = _extends({}, this.stateProvider, { contentComponent: contentComponent });
      }
      if (!oldState.wrapperComponent && wrapperComponent) {
        this.stateProvider = _extends({}, this.stateProvider, { wrapperComponent: wrapperComponent });

        // Zooming events on wrapper
        var passiveOption = makePassiveEventOption(false);
        wrapperComponent.addEventListener("mousewheel", this.handleWheel, passiveOption);
        wrapperComponent.addEventListener("dblclick", this.handleDbClick, passiveOption);
        wrapperComponent.addEventListener("touchstart", this.handleTouchStart, passiveOption);
        wrapperComponent.addEventListener("touchmove", this.handleTouch, passiveOption);
        wrapperComponent.addEventListener("touchend", this.handleTouchStop, passiveOption);
      }

      // start velocity animation
      if (this.velocity && startAnimation) animateVelocity.bind(this)();

      // when bounds limiters change
      if (oldProps.dynamicValues !== dynamicValues && (oldProps.dynamicValues.limitToBounds !== dynamicValues.limitToBounds || oldProps.dynamicValues.limitToWrapperBounds !== dynamicValues.limitToWrapperBounds)) {
        this.bounds = null;
      }

      // must be at the end of the update function
      if (oldProps.dynamicValues !== dynamicValues) {
        this.stateProvider = _extends({}, this.stateProvider, dynamicValues);
        this.forceUpdate();
      }
    }

    //////////
    // Wheel
    //////////

    //////////
    // Panning
    //////////

    //////////
    // Pinch
    //////////

    //////////
    // Touch Events
    //////////

    //////////
    // Controls
    //////////

    //////////
    // Setters
    //////////

    //////////
    // Props
    //////////

  }, {
    key: "render",
    value: function render() {
      /**
       * Context provider value
       */
      var value = {
        state: this.getCallbackProps(),
        dispatch: {
          setScale: this.setScale,
          setPositionX: this.setPositionX,
          setPositionY: this.setPositionY,
          zoomIn: this.zoomIn,
          zoomOut: this.zoomOut,
          setTransform: this.setTransform,
          resetTransform: this.resetTransform
        },
        nodes: {
          setWrapperComponent: this.setWrapperComponent,
          setContentComponent: this.setContentComponent
        },
        internal: {
          handleZoom: this.handleZoom,
          handleStartPanning: this.handleStartPanning,
          handlePanning: this.handlePanning,
          handleStopPanning: this.handleStopPanning,
          handleDbClick: this.handleDbClick,
          handleTouchStart: this.handleTouchStart,
          handleTouch: this.handleTouch,
          handleTouchStop: this.handleTouchStop
        }
      };
      var children = this.props.children;

      var content = typeof children === "function" ? children(_extends({}, value.state, value.dispatch)) : children;

      return React__default.createElement(
        Context.Provider,
        { value: value },
        content
      );
    }
  }]);
  return StateProvider;
}(React.Component);

StateProvider.defaultProps = {
  defaultValues: {},
  dynamicValues: {},
  onWheelStart: null,
  onWheel: null,
  onWheelStop: null,
  onPanningStart: null,
  onPanning: null,
  onPanningStop: null,
  onPinchingStart: null,
  onPinching: null,
  onPinchingStop: null
};

StateProvider.propTypes = {
  children: PropTypes.any,
  defaultValues: PropTypes.object,
  dynamicValues: PropTypes.object,
  onWheelStart: PropTypes.func,
  onWheel: PropTypes.func,
  onWheelStop: PropTypes.func,
  onPanningStart: PropTypes.func,
  onPanning: PropTypes.func,
  onPanningStop: PropTypes.func,
  onPinchingStart: PropTypes.func,
  onPinching: PropTypes.func,
  onPinchingStop: PropTypes.func,
  onZoomChange: PropTypes.func
};

var TransformWrapper = function TransformWrapper(_ref) {
  var children = _ref.children,
      scale = _ref.scale,
      positionX = _ref.positionX,
      positionY = _ref.positionY,
      sensitivity = _ref.sensitivity,
      maxScale = _ref.maxScale,
      minScale = _ref.minScale,
      scaleAnimationPadding = _ref.scaleAnimationPadding,
      wheelAnimationSpeed = _ref.wheelAnimationSpeed,
      zoomAnimationSpeed = _ref.zoomAnimationSpeed,
      pinchAnimationSpeed = _ref.pinchAnimationSpeed,
      panAnimationSpeed = _ref.panAnimationSpeed,
      resetAnimationSpeed = _ref.resetAnimationSpeed,
      scalePaddingAnimationSpeed = _ref.scalePaddingAnimationSpeed,
      minPositionX = _ref.minPositionX,
      minPositionY = _ref.minPositionY,
      maxPositionX = _ref.maxPositionX,
      maxPositionY = _ref.maxPositionY,
      limitToBounds = _ref.limitToBounds,
      zoomingEnabled = _ref.zoomingEnabled,
      panningEnabled = _ref.panningEnabled,
      transformEnabled = _ref.transformEnabled,
      pinchEnabled = _ref.pinchEnabled,
      limitToWrapperBounds = _ref.limitToWrapperBounds,
      disabled = _ref.disabled,
      zoomOutStep = _ref.zoomOutStep,
      zoomInStep = _ref.zoomInStep,
      dbClickStep = _ref.dbClickStep,
      pinchSensitivity = _ref.pinchSensitivity,
      dbClickEnabled = _ref.dbClickEnabled,
      lastPositionZoomEnabled = _ref.lastPositionZoomEnabled,
      enableZoomThrottling = _ref.enableZoomThrottling,
      onWheelStart = _ref.onWheelStart,
      onWheel = _ref.onWheel,
      onWheelStop = _ref.onWheelStop,
      onPanningStart = _ref.onPanningStart,
      onPanning = _ref.onPanning,
      onPanningStop = _ref.onPanningStop,
      onPinchingStart = _ref.onPinchingStart,
      onPinching = _ref.onPinching,
      onPinchingStop = _ref.onPinchingStop,
      onZoomChange = _ref.onZoomChange,
      defaultPositionX = _ref.defaultPositionX,
      defaultPositionY = _ref.defaultPositionY,
      defaultScale = _ref.defaultScale,
      lockAxisX = _ref.lockAxisX,
      lockAxisY = _ref.lockAxisY,
      velocityTimeBasedOnMove = _ref.velocityTimeBasedOnMove,
      velocitySensitivity = _ref.velocitySensitivity,
      isCentered = _ref.isCentered,
      enableWheel = _ref.enableWheel,
      enableTouchPadPinch = _ref.enableTouchPadPinch;

  return React__default.createElement(
    StateProvider,
    {
      defaultValues: deleteUndefinedProps({
        positionX: defaultPositionX,
        positionY: defaultPositionY,
        scale: defaultScale
      }),
      dynamicValues: deleteUndefinedProps({
        scale: scale,
        positionX: positionX,
        positionY: positionY,
        sensitivity: sensitivity,
        maxScale: maxScale,
        minScale: minScale,
        wheelAnimationSpeed: wheelAnimationSpeed,
        zoomAnimationSpeed: zoomAnimationSpeed,
        pinchAnimationSpeed: pinchAnimationSpeed,
        panAnimationSpeed: panAnimationSpeed,
        resetAnimationSpeed: resetAnimationSpeed,
        minPositionX: minPositionX,
        minPositionY: minPositionY,
        maxPositionX: maxPositionX,
        maxPositionY: maxPositionY,
        limitToBounds: limitToBounds,
        zoomingEnabled: zoomingEnabled,
        panningEnabled: panningEnabled,
        transformEnabled: transformEnabled,
        pinchEnabled: pinchEnabled,
        limitToWrapperBounds: limitToWrapperBounds,
        disabled: disabled,
        zoomOutStep: zoomOutStep,
        zoomInStep: zoomInStep,
        dbClickStep: dbClickStep,
        pinchSensitivity: pinchSensitivity,
        dbClickEnabled: dbClickEnabled,
        lastPositionZoomEnabled: lastPositionZoomEnabled,
        enableZoomThrottling: enableZoomThrottling,
        lockAxisX: lockAxisX,
        lockAxisY: lockAxisY,
        velocityTimeBasedOnMove: velocityTimeBasedOnMove,
        velocitySensitivity: velocitySensitivity,
        scalePaddingAnimationSpeed: scalePaddingAnimationSpeed,
        scaleAnimationPadding: scaleAnimationPadding,
        isCentered: isCentered,
        enableWheel: enableWheel,
        enableTouchPadPinch: enableTouchPadPinch
      }),
      onWheelStart: onWheelStart,
      onWheel: onWheel,
      onWheelStop: onWheelStop,
      onPanningStart: onPanningStart,
      onPanning: onPanning,
      onPanningStop: onPanningStop,
      onPinchingStart: onPinchingStart,
      onPinching: onPinching,
      onPinchingStop: onPinchingStop,
      onZoomChange: onZoomChange
    },
    children
  );
};

TransformWrapper.propTypes = {
  children: PropTypes.any,
  scale: PropTypes.number,
  positionX: PropTypes.number,
  positionY: PropTypes.number,
  sensitivity: PropTypes.number,
  maxScale: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),
  minScale: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),
  wheelAnimationSpeed: PropTypes.number,
  zoomAnimationSpeed: PropTypes.number,
  pinchAnimationSpeed: PropTypes.number,
  panAnimationSpeed: PropTypes.number,
  resetAnimationSpeed: PropTypes.number,
  minPositionX: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),
  maxPositionX: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),
  minPositionY: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),
  maxPositionY: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),
  limitToBounds: PropTypes.bool,
  zoomingEnabled: PropTypes.bool,
  panningEnabled: PropTypes.bool,
  transformEnabled: PropTypes.bool,
  pinchEnabled: PropTypes.bool,
  limitToWrapperBounds: PropTypes.bool,
  disabled: PropTypes.bool,
  zoomOutStep: PropTypes.bool,
  zoomInStep: PropTypes.bool,
  dbClickStep: PropTypes.bool,
  pinchSensitivity: PropTypes.bool,
  dbClickEnabled: PropTypes.bool,
  lastPositionZoomEnabled: PropTypes.bool,
  enableZoomThrottling: PropTypes.bool,
  onWheelStart: PropTypes.func,
  onWheel: PropTypes.func,
  onWheelStop: PropTypes.func,
  onPanningStart: PropTypes.func,
  onPanning: PropTypes.func,
  onPanningStop: PropTypes.func,
  onPinchingStart: PropTypes.func,
  onPinching: PropTypes.func,
  onPinchingStop: PropTypes.func,
  onZoomChange: PropTypes.func,
  defaultPositionX: PropTypes.number,
  defaultPositionY: PropTypes.number,
  defaultScale: PropTypes.number,
  lockAxisX: PropTypes.bool,
  lockAxisY: PropTypes.bool,
  velocityTimeBasedOnMove: PropTypes.bool,
  velocitySensitivity: PropTypes.number,
  scaleAnimationPadding: PropTypes.number,
  scalePaddingAnimationSpeed: PropTypes.number,
  isCentered: PropTypes.bool,
  enableWheel: PropTypes.bool,
  enableTouchPadPinch: PropTypes.bool
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".TransformComponent-module_container__3NwNd {\n  position: relative;\n  width: fit-content;\n  height: fit-content;\n  overflow: hidden;\n  -webkit-touch-callout: none; /* iOS Safari */\n  -webkit-user-select: none; /* Safari */\n  -khtml-user-select: none; /* Konqueror HTML */\n  -moz-user-select: none; /* Firefox */\n  -ms-user-select: none; /* Internet Explorer/Edge */\n  user-select: none;\n  margin: 0;\n  padding: 0;\n}\n.TransformComponent-module_content__TZU5O {\n  display: flex;\n  flex-wrap: wrap;\n  width: fit-content;\n  height: fit-content;\n  transform-origin: 0% 0%;\n  margin: 0;\n  padding: 0;\n}\n.TransformComponent-module_content__TZU5O img {\n  pointer-events: none;\n}\n";
var styles = { "container": "TransformComponent-module_container__3NwNd", "content": "TransformComponent-module_content__TZU5O" };
styleInject(css);

function TransformComponent(_ref) {
  var children = _ref.children;

  var wrapperRef = React.useRef(null);
  var contentRef = React.useRef(null);

  var _useContext = React.useContext(Context),
      state = _useContext.state,
      nodes = _useContext.nodes;

  var style = {
    transform: "translate(" + state.positionX + "px, " + state.positionY + "px) scale(" + state.scale + ")"
  };

  React.useEffect(function () {
    if (wrapperRef.current) {
      nodes.setWrapperComponent(wrapperRef.current);
    }
    if (contentRef.current) {
      nodes.setContentComponent(contentRef.current);
    }
  }, []);

  return React__default.createElement(
    "div",
    { ref: wrapperRef, className: "\"react-transform-component\" " + styles.container },
    React__default.createElement(
      "div",
      { ref: contentRef, className: "react-transform-element " + styles.content, style: style },
      children
    )
  );
}

TransformComponent.propTypes = { children: PropTypes.any };

exports.TransformWrapper = TransformWrapper;
exports.TransformComponent = TransformComponent;
//# sourceMappingURL=index.js.map
